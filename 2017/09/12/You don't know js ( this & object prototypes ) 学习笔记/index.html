<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="第一章：this是什么？在学习使用this之前我们首先要清楚两点： 1.this既不是函数自身的引用，也不是函数词法作用域的引用。 2.this其实是在函数调用时才建立的一个绑定，它的指向与函数声明的位置无关，而与函数调用的位置有关。 为什么要用this">
<meta name="keywords" content="javaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="You don&#39;t know js ( this &amp; object prototypes ) 学习笔记">
<meta property="og:url" content="http:/four27.com/2017/09/12/You don't know js ( this & object prototypes ) 学习笔记/index.html">
<meta property="og:site_name" content="Shirley&#39;s Blog">
<meta property="og:description" content="第一章：this是什么？在学习使用this之前我们首先要清楚两点： 1.this既不是函数自身的引用，也不是函数词法作用域的引用。 2.this其实是在函数调用时才建立的一个绑定，它的指向与函数声明的位置无关，而与函数调用的位置有关。 为什么要用this">
<meta property="og:image" content="https://github.com/getify/You-Dont-Know-JS/raw/1ed-zh-CN/this%20%26%20object%20prototypes/fig3.png">
<meta property="og:updated_time" content="2017-11-07T08:57:19.457Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You don&#39;t know js ( this &amp; object prototypes ) 学习笔记">
<meta name="twitter:description" content="第一章：this是什么？在学习使用this之前我们首先要清楚两点： 1.this既不是函数自身的引用，也不是函数词法作用域的引用。 2.this其实是在函数调用时才建立的一个绑定，它的指向与函数声明的位置无关，而与函数调用的位置有关。 为什么要用this">
<meta name="twitter:image" content="https://github.com/getify/You-Dont-Know-JS/raw/1ed-zh-CN/this%20%26%20object%20prototypes/fig3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http:/four27.com/2017/09/12/You don't know js ( this & object prototypes ) 学习笔记/"/>





  <title>You don't know js ( this & object prototypes ) 学习笔记 | Shirley's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shirley's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:/four27.com/2017/09/12/You don't know js ( this & object prototypes ) 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">You don't know js ( this & object prototypes ) 学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T15:43:10+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：this是什么？"><a href="#第一章：this是什么？" class="headerlink" title="第一章：this是什么？"></a>第一章：<code>this</code>是什么？</h1><p>在学习使用<code>this</code>之前我们首先要清楚两点：</p>
<p>1.<code>this</code>既不是函数自身的引用，也不是函数<em>词法作用域</em>的引用。</p>
<p>2.<code>this</code>其实是在函数调用时才建立的一个绑定，它的指向与函数声明的位置无关，而与函数调用的位置有关。</p>
<h2 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用<code>this</code></h2><a id="more"></a>
<p>总结：用<code>this</code>可以简化代码，不用利用频繁传参的方式来实现调用。</p>
<!-- more -->
<p>两段代码对比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function identify() &#123;</div><div class="line">	return this.name.toUpperCase();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function speak() &#123;</div><div class="line">	var greeting = &quot;Hello, I&apos;m &quot; + identify.call( this );</div><div class="line">	console.log( greeting );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var me = &#123;</div><div class="line">	name: &quot;Kyle&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var you = &#123;</div><div class="line">	name: &quot;Reader&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">identify.call( me ); // KYLE</div><div class="line">identify.call( you ); // READER</div><div class="line"></div><div class="line">speak.call( me ); // Hello, I&apos;m KYLE</div><div class="line">speak.call( you ); // Hello, I&apos;m READER</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function identify(context) &#123;</div><div class="line">	return context.name.toUpperCase();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function speak(context) &#123;</div><div class="line">	var greeting = &quot;Hello, I&apos;m &quot; + identify( context );</div><div class="line">	console.log( greeting );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var me = &#123;</div><div class="line">	name: &quot;Kyle&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var you = &#123;</div><div class="line">	name: &quot;Reader&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">identify( you ); // READER</div><div class="line">speak( me ); // Hello, I&apos;m KYLE</div></pre></td></tr></table></figure>
<p>虽然两段代码实现的效果是一样的，但是有<code>this</code>的存在代码会更简洁。尤其是在使用模式更复杂的情况下，越能深刻的感受到这一点。所以这就是我们要学会使用<code>this</code>的原因。</p>
<h2 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h2><h3 id="它自己"><a href="#它自己" class="headerlink" title="它自己"></a>它自己</h3><p>对于<code>this</code>的第一种误解就是：它指向函数自己（我最开始就是这么认为的:smiley:）。</p>
<p>用一个栗子来解释这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line"></div><div class="line">	// 追踪 `foo` 被调用了多少次</div><div class="line">	this.count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.count = 0;</div><div class="line"></div><div class="line">var i;</div><div class="line"></div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line"></div><div class="line">// `foo` 被调用了多少次？</div><div class="line">console.log( foo.count ); // 0 喵喵喵？</div></pre></td></tr></table></figure>
<p>这段代码的原意是想要追踪<code>foo</code>被调用了多少次。但是，最后的<code>foo.count</code>却没有发生变化，依然为<code>0</code>。</p>
<p>其中，<code>foo.count</code>向<code>foo</code>添加了一个<code>count</code>属性。但是，<code>this.count</code>并没有指向这个添加的<code>count</code>，即使属性名称相同，但它们的根对象是不同的。</p>
<p>这是我们可以用两种方式来解决这一问题：</p>
<p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line"></div><div class="line">	// 追踪 `foo` 被调用了多少次</div><div class="line">	data.count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var data = &#123;</div><div class="line">	count: 0</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var i;</div><div class="line"></div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line"></div><div class="line">// `foo` 被调用了多少次？</div><div class="line">console.log( data.count ); // 4</div></pre></td></tr></table></figure>
<p>通过建立一个全局变量，让函数<code>foo</code>改变全局变量中持有的<code>count</code>。虽然解决了问题，但是它回避了<code>this</code>。</p>
<p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line"></div><div class="line">	// 追踪 `foo` 被调用了多少次</div><div class="line">	foo.count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.count = 0;</div><div class="line"></div><div class="line">var i;</div><div class="line"></div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line"></div><div class="line">// `foo` 被调用了多少次？</div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure>
<p>第三种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line"></div><div class="line">	// 追踪 `foo` 被调用了多少次</div><div class="line">	// 注意：由于 `foo` 的被调用方式（见下方），`this` 现在确实是 `foo`</div><div class="line">	this.count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.count = 0;</div><div class="line"></div><div class="line">var i;</div><div class="line"></div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		// 使用 `call(..)`，我们可以保证 `this` 指向函数对象(`foo`)</div><div class="line">		foo.call( foo, i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line"></div><div class="line">// `foo` 被调用了多少次？</div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure>
<p>但是上面三种方法都回避了<code>this</code>。</p>
<h3 id="它的作用域"><a href="#它的作用域" class="headerlink" title="它的作用域"></a>它的作用域</h3><p>对于<code>this</code>的第二种误解就是：它指向函数的作用域。</p>
<p>参考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	var a = 2;</div><div class="line">	this.bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); //undefined</div></pre></td></tr></table></figure>
<p>写下这段代码的开发者试图用 <code>this</code> 在 <code>foo()</code> 和 <code>bar()</code> 的词法作用域间建立一座桥，使得<code>bar()</code> 可以访问 <code>foo()</code>内部作用域的变量 <code>a</code>。<strong>这样的桥是不可能的。</strong> 你不能使用 <code>this</code> 引用在词法作用域中查找东西。这是不可能的。</p>
<p>每当你感觉自己正在试图使用 <code>this</code> 来进行词法作用域的查询时，提醒你自己：<em>这里没有桥</em>。</p>
<h2 id="什么是this？"><a href="#什么是this？" class="headerlink" title="什么是this？"></a>什么是<code>this</code>？</h2><p><code>this</code> 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。<strong><code>this</code> 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</strong></p>
<h1 id="第二章：this豁然开朗"><a href="#第二章：this豁然开朗" class="headerlink" title="第二章：this豁然开朗"></a>第二章：<code>this</code>豁然开朗</h1><h2 id="调用点（Call-site）"><a href="#调用点（Call-site）" class="headerlink" title="调用点（Call-site）"></a>调用点（Call-site）</h2><p>调用点（call-site）：函数在代码中被调用的位置（不是被声明的位置）；</p>
<p>调用栈（call-stack）：使我们到达当前执行位置而被调用的所有方法的堆栈。</p>
<p>关于调用点和调用栈的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function baz() &#123;</div><div class="line">    // 调用栈是: `baz`</div><div class="line">    // 我们的调用点是 global scope（全局作用域）</div><div class="line"></div><div class="line">    console.log( &quot;baz&quot; );</div><div class="line">    bar(); // &lt;-- `bar` 的调用点</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">    // 调用栈是: `baz` -&gt; `bar`</div><div class="line">    // 我们的调用点位于 `baz`</div><div class="line"></div><div class="line">    console.log( &quot;bar&quot; );</div><div class="line">    foo(); // &lt;-- `foo` 的 call-site</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">    // 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</div><div class="line">    // 我们的调用点位于 `bar`</div><div class="line"></div><div class="line">    console.log( &quot;foo&quot; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">baz(); // &lt;-- `baz` 的调用点</div></pre></td></tr></table></figure>
<p>可以通过<code>console.trace()</code>在控制台中查看调用栈。</p>
<h2 id="四种规则"><a href="#四种规则" class="headerlink" title="四种规则"></a>四种规则</h2><p>下面介绍判断<code>this</code>指向的四种判断规则：</p>
<h3 id="默认绑定（Default-Binding）"><a href="#默认绑定（Default-Binding）" class="headerlink" title="默认绑定（Default Binding）"></a>默认绑定（Default Binding）</h3><p>这是函数调用最常用的情况：独立函数调用。也可以认为这种<code>this</code>规则是在没有其他规则适用时的默认规则。</p>
<p>当函数是 <strong>一个直白，毫无修饰的调用时</strong>，即默认绑定时，有两种情况：</p>
<p>1、<code>foo</code>内容没在<code>strict mode</code>下，<code>this</code>指向全局变量。</p>
<p>2、<code>foo</code>内容在<code>strict mode</code>下，<code>this</code>将被设置为<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line"></div><div class="line">foo(); // 2</div></pre></td></tr></table></figure>
<p>此时的<code>this</code>实施了默认绑定，使<code>this</code>指向了全局变量。所以<code>this.a</code>引用的是全局变量中的<code>a</code>。</p>
<p>但是如果<code>strict mode</code>在这里生效，name对于默认绑定来说是不合法的。此时的<code>this</code>将被设置为<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	&quot;use strict&quot;;</div><div class="line"></div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line"></div><div class="line">foo(); // TypeError: `this` is `undefined`</div></pre></td></tr></table></figure>
<p>一个微妙但是重要的细节是：即便所有的 <code>this</code> 绑定规则都是完全基于调用点的，但如果 <code>foo()</code> 的 <strong>内容</strong> 没有在 <code>strict mode</code>下执行，对于 <em>默认绑定</em> 来说全局对象是 <strong>唯一</strong> 合法的；<code>foo()</code> 的调用点的 <code>strict mode</code> 状态与此无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function()&#123;</div><div class="line">	&quot;use strict&quot;;</div><div class="line"></div><div class="line">	foo(); // 2</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h3 id="隐含绑定（Implicit-Binding）"><a href="#隐含绑定（Implicit-Binding）" class="headerlink" title="隐含绑定（Implicit Binding）"></a>隐含绑定（Implicit Binding）</h3><p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo(); // 2</div></pre></td></tr></table></figure>
<p>观察这段代码会发现，<code>foo()</code>函数是在<code>obj</code>的环境下调用的，所以它的调用点是在<code>obj</code>对象这里。因此<code>this</code>就很自然的绑定在<code>obj</code>对象上。</p>
<p>在看一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj2 = &#123;</div><div class="line">	a: 42,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var obj1 = &#123;</div><div class="line">	a: 2,</div><div class="line">	obj2: obj2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.obj2.foo(); // 42</div></pre></td></tr></table></figure>
<p>书上解释这一段代码的时候说：<strong>只有对象属性引用链的最后一层是影响调用点的。</strong></p>
<p>其实，原理也很简单，因为<code>foo()</code>函数是在<code>obj2</code>环境下被调用的，所以它的调用点在<code>obj2</code>这里。自然而然的<code>this.a</code>就和<code>obj2.a</code>等价了，我么判断这种隐含绑定的时候关注调用点就对了。</p>
<h4 id="隐含丢失（Implicitly-Lost）"><a href="#隐含丢失（Implicitly-Lost）" class="headerlink" title="隐含丢失（Implicitly Lost）"></a>隐含丢失（Implicitly Lost）</h4><p>当隐含绑定丢失时，这通常以为着<code>this</code>会回退到默认绑定。然后根据<code>strict mode</code>存在与否来判断，<code>this</code>的指向是全局对象还是<code>undefined</code>。</p>
<p>第一种：调用点的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bar = obj.foo; // 函数引用！</div><div class="line"></div><div class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</div><div class="line"></div><div class="line">bar(); // &quot;oops, global&quot;   // 调用点</div></pre></td></tr></table></figure>
<p>因为函数<code>bar()</code>真正的 <strong>调用点</strong>没有任何其他的修饰所以它的<code>this</code>就为默认绑定。</p>
<p>第二种：传递一个回调函数时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function doFoo(fn) &#123;</div><div class="line">	// `fn` 只不过 `foo` 的另一个引用</div><div class="line"></div><div class="line">	fn(); // &lt;-- 调用点!</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</div><div class="line"></div><div class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</div></pre></td></tr></table></figure>
<p>其实就可以理解为：回调函数导致了函数调用点的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</div><div class="line"></div><div class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</div></pre></td></tr></table></figure>
<p>将<code>setTimeout</code>函数展开为下面形式，即js环境内建的实现，就很好理解了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function setTimeout(fn,delay) &#123;</div><div class="line">  // （通过某种方法）等待 `delay` 毫秒</div><div class="line">	fn(); // &lt;-- 调用点!</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="明确绑定（Explicit-Binding）"><a href="#明确绑定（Explicit-Binding）" class="headerlink" title="明确绑定（Explicit Binding）"></a>明确绑定（Explicit Binding）</h3><p>从上述的隐含绑定中可以看出这种绑定都是隐性的，下面我们就要看到一个很直接的绑定方式。</p>
<p>其实前面我们就有接触了，<code>call()</code>和<code>apply()</code>就是明确绑定很好的实现方式。</p>
<p>它们接收的第一个参数都是一个用于 <code>this</code> 的对象，之后使用这个指定的 <code>this</code> 来调用函数。因为你已经直接指明你想让 <code>this</code> 是什么，所以我们称这种方式为 <em>明确绑定（explicit binding)</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure>
<p>不幸的是，单独依靠 <em>明确绑定</em> 仍然不能为我们先前提到的问题提供解决方案，也就是函数“丢失”自己原本的 <code>this</code> 绑定，或者被第三方框架覆盖，等等问题。</p>
<h4 id="硬绑定（Hard-Binding）"><a href="#硬绑定（Hard-Binding）" class="headerlink" title="硬绑定（Hard Binding）"></a>硬绑定（Hard Binding）</h4><p>明确绑定的一种变种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bar = function() &#123;</div><div class="line">	foo.call( obj );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar(); // 2</div><div class="line">setTimeout( bar, 100 ); // 2</div><div class="line"></div><div class="line">var obj2 = &#123;</div><div class="line">    a: 3</div><div class="line">&#125;</div><div class="line">// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`</div><div class="line">// 所以它不可以被覆盖</div><div class="line">bar.call( obj2 ); // 2</div></pre></td></tr></table></figure>
<h3 id="new-绑定（new-Binding）"><a href="#new-绑定（new-Binding）" class="headerlink" title="new 绑定（new Binding）"></a><code>new</code> 绑定（<code>new</code> Binding）</h3><p>当在函数前面被加入 <code>new</code> 调用时，也就是构造器调用时，下面这些事情会自动完成：</p>
<ol>
<li>一个全新的 <strong>对象</strong>会凭空创建（就是被构建）</li>
<li><em>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</em></li>
<li><strong>这个新构建的对象被设置为函数调用的 <code>this</code> 绑定</strong></li>
<li>除非函数返回一个它自己的其他 <strong>对象</strong>，否则这个被 <code>new</code> 调用的函数将 <em>自动</em> 返回这个新构建的对象。</li>
</ol>
<p><strong>注意：new构建的是一个全新的对象而不是一个函数，是将构造器中的this绑定到新的对象上。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	this.a = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = new foo( 2 );</div><div class="line">console.log( bar.a ); // 2</div><div class="line"></div><div class="line">对比</div><div class="line"></div><div class="line">function foo(a) &#123;</div><div class="line">	this.a = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = foo( 2 );</div><div class="line">console.log( bar.a ); // TypeError</div></pre></td></tr></table></figure>
<p>通过在前面使用 <code>new</code> 来调用 <code>foo(..)</code>，我们构建了一个新的对象并把这个新对象作为 <code>foo(..)</code> 调用的 <code>this</code>。 <strong>new 是函数调用可以绑定 this 的最后一种方式</strong>，我们称之为 <em>new 绑定（new binding）</em>。</p>
<h2 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h2><p>比较隐含绑定和明确绑定哪一个优先？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj1 = &#123;</div><div class="line">	a: 2,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var obj2 = &#123;</div><div class="line">	a: 3,</div><div class="line">	foo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.foo(); // 2</div><div class="line">obj2.foo(); // 3</div><div class="line"></div><div class="line">obj1.foo.call( obj2 ); // 3</div><div class="line">obj2.foo.call( obj1 ); // 2</div></pre></td></tr></table></figure>
<p>明确绑定优先于隐含绑定</p>
<p>比较硬绑定与<code>new</code>绑定的优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(something) &#123;</div><div class="line">	this.a = something;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj1 = &#123;&#125;;</div><div class="line"></div><div class="line">var bar = foo.bind( obj1 );</div><div class="line">bar( 2 );</div><div class="line">console.log( obj1.a ); // 2</div><div class="line"></div><div class="line">var baz = new bar( 3 );</div><div class="line">console.log( obj1.a ); // 2</div><div class="line">console.log( baz.a ); // 3</div></pre></td></tr></table></figure>
<p>参考“山寨”绑定帮助函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bind(fn, obj) &#123;</div><div class="line">	return function() &#123;</div><div class="line">		fn.apply( obj, arguments );</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上面的代码我们会发现：<strong><code>new</code>绑定无法将硬绑定时的<code>obj1</code>对象覆盖。所以硬绑定的优先级要大于<code>new</code>绑定。</strong></p>
<p><code>new</code>可以覆盖硬绑定一种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(p1,p2) &#123;</div><div class="line">	this.val = p1 + p2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 在这里使用 `null` 是因为在这种场景下我们不关心 `this` 的硬绑定</div><div class="line">// 而且反正它将会被 `new` 调用覆盖掉！</div><div class="line">// 这种方式称为bind的柯里化</div><div class="line">var bar = foo.bind( null, &quot;p1&quot; );</div><div class="line"></div><div class="line">var baz = new bar( &quot;p2&quot; );</div><div class="line"></div><div class="line">baz.val; // p1p2</div></pre></td></tr></table></figure>
<h3 id="判定this"><a href="#判定this" class="headerlink" title="判定this"></a>判定<code>this</code></h3><ol>
<li><p>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。</p>
<p><code>var bar = new foo()</code></p>
</li>
<li><p>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。</p>
<p><code>var bar = foo.call( obj2 )</code></p>
</li>
<li><p>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。</p>
<p><code>var bar = obj1.foo()</code></p>
</li>
<li><p>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。</p>
<p><code>var bar = foo()</code></p>
</li>
</ol>
<p>以上，就是理解对于普通的函数调用来说的 <code>this</code> 绑定规则 <em>所需的全部</em>。是的……几乎是全部。</p>
<h2 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h2><p>主要介绍规则的一些例外。</p>
<h3 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的<code>this</code></h3><p>如果你传递 <code>null</code> 或 <code>undefined</code> 作为 <code>call</code>、<code>apply</code> 或 <code>bind</code> 的 <code>this</code> 绑定参数，那么这些值会被忽略掉，取而代之的是 <em>默认绑定</em> 规则将适用于这个调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line"></div><div class="line">foo.call( null ); // 2</div></pre></td></tr></table></figure>
<p>使用这种做法的原因：</p>
<ul>
<li>使用<code>apply(...)</code>来展开一个数组，作为函数调用的参数；</li>
<li><code>bind(...)</code>可以柯里化参数（增加预设值）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">	console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 将数组散开作为参数</div><div class="line">foo.apply( null, [2, 3] ); // a:2, b:3</div><div class="line"></div><div class="line">// 用 `bind(..)` 进行柯里化</div><div class="line">var bar = foo.bind( null, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>ES6中已经有一个扩展操作符：<code>...</code>，它可以让你无需使用 <code>apply(..)</code> 而在语法上将一个数组“散开”作为参数，比如 <code>foo(...[1,2])</code> 表示 <code>foo(1,2)</code>。</p>
<p>可是，在你不关心 <code>this</code> 绑定而一直使用 <code>null</code> 的时候，有些潜在的“危险”。如果你这样处理一些函数调用（比如，不归你管控的第三方包），而且那些函数确实使用了 <code>this</code> 引用，那么 <em>默认绑定</em> 规则意味着它可能会不经意间引用（或者改变，更糟糕！）<code>global</code> 对象（在浏览器中是 <code>window</code>）。</p>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的<code>this</code></h4><p>更安全的做法是<strong>创建一个</strong>‘DMZ’（非军事区）<strong>对象</strong>——只不过是一个<strong>完全为空</strong>。没有委托的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(a,b) &#123;</div><div class="line">	console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 我们的 DMZ 空对象</div><div class="line">var ø = Object.create( null );</div><div class="line"></div><div class="line">// 将数组散开作为参数</div><div class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</div><div class="line"></div><div class="line">// 用 `bind(..)` 进行 currying</div><div class="line">var bar = foo.bind( ø, 2 );</div><div class="line">bar( 3 ); // a:2, b:3</div></pre></td></tr></table></figure>
<h3 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h3><p>创建对函数的“间接引用”。</p>
<p>常见的间接引用产生方式是通过赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( this.a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line">var o = &#123; a: 3, foo: foo &#125;;</div><div class="line">var p = &#123; a: 4 &#125;;</div><div class="line"></div><div class="line">o.foo(); // 3</div><div class="line">(p.foo = o.foo)(); // 2</div></pre></td></tr></table></figure>
<p>赋值表达式 <code>p.foo = o.foo</code>，<code>a</code>的值到底为什么我们应该关心函数<code>foo</code>的调用点， <code>p.foo = o.foo</code>的作用是在对象<code>p</code>中创建了一个<code>foo:foo</code>，而真正调用<code>foo</code>的是在全局下。所以，输出值理所为<code>2</code>。</p>
<h3 id="软化绑定"><a href="#软化绑定" class="headerlink" title="软化绑定"></a>软化绑定</h3><p>我们之前看到 <em>硬绑定</em> 是一种通过将函数强制绑定到特定的 <code>this</code> 上，来防止函数调用在不经意间退回到 <em>默认绑定</em>的策略（除非你用 <code>new</code> 去覆盖它！）。问题是，<em>硬绑定</em> 极大地降低了函数的灵活性，阻止我们手动使用 <em>隐含绑定</em>或后续的 <em>明确绑定</em> 来覆盖 <code>this</code>。</p>
<p>如果有这样的办法就好了：为 <em>默认绑定</em> 提供不同的默认值（不是 <code>global</code> 或 <code>undefined</code>），同时保持函数可以通过 <em>隐含绑定</em> 或 <em>明确绑定</em> 技术来手动绑定 <code>this</code>。</p>
<p>我们可以构建一个所谓的 <em>软绑定</em> 工具来模拟我们期望的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (!Function.prototype.softBind) &#123;</div><div class="line">	Function.prototype.softBind = function(obj) &#123;</div><div class="line">		var fn = this,</div><div class="line">			curried = [].slice.call( arguments, 1 ),</div><div class="line">			bound = function bound() &#123;</div><div class="line">				return fn.apply(</div><div class="line">					(!this ||</div><div class="line">						(typeof window !== &quot;undefined&quot; &amp;&amp;</div><div class="line">							this === window) ||</div><div class="line">						(typeof global !== &quot;undefined&quot; &amp;&amp;</div><div class="line">							this === global)</div><div class="line">					) ? obj : this,</div><div class="line">					curried.concat.apply( curried, arguments )</div><div class="line">				);</div><div class="line">			&#125;;</div><div class="line">		bound.prototype = Object.create( fn.prototype );</div><div class="line">		return bound;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里提供的 <code>softBind(..)</code> 工具的工作方式和 ES5 内建的 <code>bind(..)</code> 工具很相似，除了我们的 <em>软绑定</em> 行为。它用一种逻辑将指定的函数包装起来，这个逻辑在函数调用时检查 <code>this</code>，如果它是 <code>global</code> 或 <code>undefined</code>，就使用预先指定的 <em>默认值</em> （<code>obj</code>），否则保持 <code>this</code> 不变。它也提供了可选的柯里化行为（见先前的 <code>bind(..)</code> 讨论）。</p>
<p>我们来看看它的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">   console.log(&quot;name: &quot; + this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123; name: &quot;obj&quot; &#125;,</div><div class="line">    obj2 = &#123; name: &quot;obj2&quot; &#125;,</div><div class="line">    obj3 = &#123; name: &quot;obj3&quot; &#125;;</div><div class="line"></div><div class="line">var fooOBJ = foo.softBind( obj );</div><div class="line"></div><div class="line">fooOBJ(); // name: obj</div><div class="line"></div><div class="line">obj2.foo = foo.softBind(obj);</div><div class="line">obj2.foo(); // name: obj2   &lt;---- 看!!!</div><div class="line"></div><div class="line">fooOBJ.call( obj3 ); // name: obj3   &lt;---- 看!</div><div class="line"></div><div class="line">setTimeout( obj2.foo, 10 ); // name: obj   &lt;---- 退回到软绑定</div></pre></td></tr></table></figure>
<p>软绑定版本的 <code>foo()</code> 函数可以如展示的那样被手动 <code>this</code> 绑定到 <code>obj2</code> 或 <code>obj3</code>，如果 <em>默认绑定</em> 适用时会退到 <code>obj</code>。</p>
<h2 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法<code>this</code></h2><p>箭头函数与使用四种标准的<code>this</code>规则不同的是，箭头函数从封闭它的（函数或全局）作用域采用<code>this</code>绑定。即，箭头函数以声明它的函数为它的全局，再利用四种规则来决定<code>this</code>的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  // 返回一个箭头函数</div><div class="line">	return (a) =&gt; &#123;</div><div class="line">    // 这里的 `this` 是词法上从 `foo()` 采用的</div><div class="line">		console.log( this.a );</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj1 = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var obj2 = &#123;</div><div class="line">	a: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bar = foo.call( obj1 );</div><div class="line">bar.call( obj2 ); // 2, 不是3!</div></pre></td></tr></table></figure>
<p>产生上述结果的原因是：一个箭头函数的此法绑定是不能被覆盖的（就连<code>new</code>也不行）。</p>
<p>ES6之前的一种引用形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	var self = this; // 词法上捕获 `this`</div><div class="line">	setTimeout( function()&#123;</div><div class="line">		console.log( self.a );</div><div class="line">	&#125;, 100 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.call( obj ); // 2</div></pre></td></tr></table></figure>
<p>在编码时应该统一风格，词法和<code>this</code>不应该混用。</p>
<h1 id="第三章：对象"><a href="#第三章：对象" class="headerlink" title="第三章：对象"></a>第三章：对象</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>字面语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myObj = &#123;</div><div class="line">	key: value</div><div class="line">	// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>构造形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myObj = new Object();</div><div class="line">myObj.key = value;</div></pre></td></tr></table></figure>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>js的七种基本数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
<li>Symbol</li>
</ul>
<p>前五种基本类型自身不是<code>object</code>，<code>null</code>有时会被当成一个对象类型。<code>typeof(null)</code>会返回<code>object</code>，实际山，<code>null</code>是它自己的基本类型。</p>
<p><strong>一个常见的错误论断是“JavaScript中的一切都是对象”。这明显是不对的</strong></p>
<p><code>function</code>和数组都是对象。</p>
<h3 id="内建对象"><a href="#内建对象" class="headerlink" title="内建对象"></a>内建对象</h3><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>这些内建函数的每一个都可以被当做构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var strPrimitive = &quot;I am a string&quot;;</div><div class="line">typeof strPrimitive;							// &quot;string&quot;</div><div class="line">strPrimitive instanceof String;					// false</div><div class="line"></div><div class="line">var strObject = new String( &quot;I am a string&quot; );</div><div class="line">typeof strObject; 								// &quot;object&quot;</div><div class="line">strObject instanceof String;					// true</div><div class="line"></div><div class="line">// 考察 object 子类型</div><div class="line">Object.prototype.toString.call( strObject );	// [object String]</div></pre></td></tr></table></figure>
<p>但更推荐使用字面形式的值，而非构造的对象形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var strPrimitive = &quot;I am a string&quot;;</div><div class="line"></div><div class="line">console.log( strPrimitive.length );			// 13</div><div class="line"></div><div class="line">console.log( strPrimitive.charAt( 3 ) );	// &quot;m&quot;</div></pre></td></tr></table></figure>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>属性访问和键访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a;		// 2    // 属性访问</div><div class="line"></div><div class="line">myObject[&quot;a&quot;];	// 2    // 键访问</div></pre></td></tr></table></figure>
<p>属性访问：<code>.</code>操作符后面需要一个<code>标识符</code>兼容的属性名；</p>
<p>键访问：<code>[]</code>中可以接受任何兼容UTF-8/unicode的字符串作为属性名。</p>
<p>例：名为“Super-Fun!”的属性，不得不使用<code>[&quot;Super-Fun&quot;]</code>语法访问。</p>
<p><code>[]</code>中还可以跟一个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var wantA = true;</div><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var idx;</div><div class="line"></div><div class="line">if (wantA) &#123;</div><div class="line">	idx = &quot;a&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 稍后</div><div class="line"></div><div class="line">console.log( myObject[idx] ); // 2</div></pre></td></tr></table></figure>
<p><code>[]</code>中的属性名<strong>总是</strong>字符串，不要将对象和数组使用的数字搞混：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123; &#125;;</div><div class="line"></div><div class="line">myObject[true] = &quot;foo&quot;;</div><div class="line">myObject[3] = &quot;bar&quot;;</div><div class="line">myObject[myObject] = &quot;baz&quot;;</div><div class="line"></div><div class="line">myObject[&quot;true&quot;];				// &quot;foo&quot;</div><div class="line">myObject[&quot;3&quot;];					// &quot;bar&quot;</div><div class="line">myObject[&quot;[object Object]&quot;];	// &quot;baz&quot;</div></pre></td></tr></table></figure>
<h3 id="计算型属性名"><a href="#计算型属性名" class="headerlink" title="计算型属性名"></a>计算型属性名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var prefix = &quot;foo&quot;;</div><div class="line"></div><div class="line">var myObject = &#123;</div><div class="line">	[prefix + &quot;bar&quot;]: &quot;hello&quot;,</div><div class="line">	[prefix + &quot;baz&quot;]: &quot;world&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject[&quot;foobar&quot;]; // hello</div><div class="line">myObject[&quot;foobaz&quot;]; // world</div></pre></td></tr></table></figure>
<p><code>ES6</code>中添加的新的数据类型<code>Symbol</code>的应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	[Symbol.Something]: &quot;hello world&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="属性vs-方法"><a href="#属性vs-方法" class="headerlink" title="属性vs.方法"></a>属性vs.方法</h3><p>每次你访问一个对象的属性都是一个 <strong>属性访问</strong>，无论你得到什么类型的值。如果你 <em>恰好</em> 从属性访问中得到一个函数，它也没有魔法般地在那时成为一个“方法”。一个从属性访问得来的函数没有任何特殊性（隐含的 <code>this</code> 绑定的情况在刚才已经解释过了）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( &quot;foo&quot; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var someFoo = foo;	// 对 `foo` 的变量引用</div><div class="line"></div><div class="line"></div><div class="line">var myObject = &#123;</div><div class="line">	someFoo: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo;				// function foo()&#123;..&#125;</div><div class="line"></div><div class="line">someFoo;			// function foo()&#123;..&#125;</div><div class="line"></div><div class="line">myObject.someFoo;	// function foo()&#123;..&#125;</div></pre></td></tr></table></figure>
<p><code>someFoo</code> 和 <code>myObject.someFoo</code> 只不过是同一个函数的两个分离的引用，它们中的任何一个都不意味着这个函数很特别或被其他对象所“拥有”。如果上面的 <code>foo()</code> 定义里面拥有一个 <code>this</code> 引用，那么 <code>myObject.someFoo</code> 的 <em>隐含绑定</em> 将会是这个两个引用间 <strong>唯一</strong> 可以观察到的不同。它们中的任何一个都没有称为“方法”的道理。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>数组也是对象。</strong>所以虽然每个索引都是正整数，还是可以在数组上添加属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class="line"></div><div class="line">myArray.baz = &quot;baz&quot;;</div><div class="line"></div><div class="line">myArray.length;	// 3</div><div class="line"></div><div class="line">myArray.baz;	// &quot;baz&quot;</div></pre></td></tr></table></figure>
<p><strong>注意：添加命名属性（不论是使用<code>.</code>还是<code>[]</code>操作符语法）不会改变数组<code>length</code>的值。</strong></p>
<p><strong>小心</strong>： 如果你试图在一个数组上添加属性，但是属性名 看起来 像一个数字，那么最终它会成为一个数字索引（也就是改变了数组的内容）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ];</div><div class="line"></div><div class="line">myArray[&quot;3&quot;] = &quot;baz&quot;;</div><div class="line"></div><div class="line">myArray.length;	// 4</div><div class="line"></div><div class="line">myArray[3];		// &quot;baz&quot;</div></pre></td></tr></table></figure>
<h3 id="（？）复制对象"><a href="#（？）复制对象" class="headerlink" title="（？）复制对象"></a>（？）复制对象</h3><p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function anotherFunction() &#123; /*..*/ &#125;</div><div class="line"></div><div class="line">var anotherObject = &#123;</div><div class="line">	c: true</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherArray = [];</div><div class="line"></div><div class="line">var myObject = &#123;</div><div class="line">	a: 2,</div><div class="line">	b: anotherObject,	// 引用，不是拷贝!</div><div class="line">	c: anotherArray,	// 又一个引用!</div><div class="line">	d: anotherFunction</div><div class="line">&#125;;</div><div class="line"></div><div class="line">anotherArray.push( anotherObject, myObject );</div></pre></td></tr></table></figure>
<p>浅拷贝：得到一个新的对象，<code>a</code>是值<code>2</code>的拷贝，但<code>b</code>、<code>c</code>、<code>d</code>属性仅仅是引用；</p>
<p>深拷贝：不仅复制<code>myobject</code>，还会复制<code>anotherObject</code> 和 <code>anotherArray</code>，就会得到一个无限循环的问题。</p>
<p>浅拷贝易懂，所以ES6为此任务定义了<code>Object.assign(...)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var newObj = Object.assign( &#123;&#125;, myObject );</div><div class="line"></div><div class="line">newObj.a;						// 2</div><div class="line">newObj.b === anotherObject;		// true</div><div class="line">newObj.c === anotherArray;		// true</div><div class="line">newObj.d === anotherFunction;	// true</div></pre></td></tr></table></figure>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>查看属性描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );    // 在myObject对象	中，查看a值的属性</div><div class="line">// &#123;</div><div class="line">//    value: 2,</div><div class="line">//    writable: true,</div><div class="line">//    enumerable: true,</div><div class="line">//    configurable: true</div><div class="line">// &#125;</div></pre></td></tr></table></figure>
<p>定义属性描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 2,</div><div class="line">	writable: true,</div><div class="line">	configurable: true,</div><div class="line">	enumerable: true</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.a; // 2</div></pre></td></tr></table></figure>
<h4 id="可写性（writable"><a href="#可写性（writable" class="headerlink" title="可写性（writable)"></a>可写性（writable)</h4><p>即表示该属性值能否被更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 2,</div><div class="line">	writable: false, // 不可写！</div><div class="line">	configurable: true,</div><div class="line">	enumerable: true</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.a = 3;</div><div class="line"></div><div class="line">myObject.a; // 2</div></pre></td></tr></table></figure>
<p>在<code>strict mode</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">var myObject = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 2,</div><div class="line">	writable: false, // 不可写！</div><div class="line">	configurable: true,</div><div class="line">	enumerable: true</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.a = 3; // TypeErro</div></pre></td></tr></table></figure>
<h4 id="可配置型（Configurable）"><a href="#可配置型（Configurable）" class="headerlink" title="可配置型（Configurable）"></a>可配置型（Configurable）</h4><p>即是否能定义属性描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a = 3;</div><div class="line">myObject.a;					// 3</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 4,</div><div class="line">	writable: true,</div><div class="line">	configurable: false,	// 不可配置！</div><div class="line">	enumerable: true</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.a;					// 4</div><div class="line">myObject.a = 5;</div><div class="line">myObject.a;					// 5</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 6,</div><div class="line">	writable: true,</div><div class="line">	configurable: true,</div><div class="line">	enumerable: true</div><div class="line">&#125; ); // TypeError</div></pre></td></tr></table></figure>
<p>注意：这里直接导致了TypeError，与<code>strict mode</code>无关。</p>
<p>注意：将<code>configurable</code>设置为<code>false</code>是一个<strong>单项操作，不可撤销！</strong></p>
<p><code>configurable:false</code> 阻止的另外一个事情是使用 <code>delete</code> 操作符移除既存属性的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a;				// 2</div><div class="line">delete myObject.a;</div><div class="line">myObject.a;				// undefined</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</div><div class="line">	value: 2,</div><div class="line">	writable: true,</div><div class="line">	configurable: false,</div><div class="line">	enumerable: true</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.a;				// 2</div><div class="line">delete myObject.a;</div><div class="line">myObject.a;				// 2</div></pre></td></tr></table></figure>
<p>如你所见，最后的 <code>delete</code> 调用（无声地）失败了，因为我们将 <code>a</code> 属性设置成了不可配置。</p>
<p><code>delete</code> 仅用于直接从目标对象移除该对象的（可以被移除的）属性。如果一个对象的属性是某个其他对象/函数的最后一个现存的引用，而你 <code>delete</code> 了它，那么这就移除了这个引用，于是现在那个没有被任何地方所引用的对象/函数就可以被作为垃圾回收。但是，将 <code>delete</code> 当做一个像其他语言（如 C/C++）中那样的释放内存工具是 <strong>不</strong> 恰当的。<code>delete</code> 仅仅是一个对象属性移除操作 —— 没有更多别的含义。</p>
<h4 id="可枚举性（Enumerable）"><a href="#可枚举性（Enumerable）" class="headerlink" title="可枚举性（Enumerable）"></a>可枚举性（Enumerable）</h4><p>即属性呢能否在特定对象-属性枚举操作中出现，比如<code>for...in</code>循环。</p>
<h3 id="不可变性（Immutability）"><a href="#不可变性（Immutability）" class="headerlink" title="不可变性（Immutability）"></a>不可变性（Immutability）</h3><p>即属性或对象的不可变性。</p>
<p>ES5实现不可变性的方法都只是实现了浅不可变性。也就是，他们仅影响对象和它的直属属性的性质。如果对象拥有对其他对象（数组、对象、函数等）的引用，那个对象的内容就不会受影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myImmutableObject.foo; // [1,2,3]</div><div class="line">myImmutableObject.foo.push( 4 );</div><div class="line">myImmutableObject.foo; // [1,2,3,4]</div></pre></td></tr></table></figure>
<h4 id="对象常量（Object-Constant）"><a href="#对象常量（Object-Constant）" class="headerlink" title="对象常量（Object Constant）"></a>对象常量（Object Constant）</h4><p>将<code>writable:false</code>和<code>configurable</code>组合，可以在实质上创建一个作为对象属性的常量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty( myObject, &quot;FAVORITE_NUMBER&quot;, &#123;</div><div class="line">	value: 42,</div><div class="line">	writable: false,</div><div class="line">	configurable: false</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h4 id="防止扩展（Prevent-Extensions）"><a href="#防止扩展（Prevent-Extensions）" class="headerlink" title="防止扩展（Prevent Extensions）"></a>防止扩展（Prevent Extensions）</h4><p>防止对象添加新的属性，保留既存的对象属性。调用<code>Object.preventExtensions(...)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.preventExtensions( myObject );</div><div class="line"></div><div class="line">myObject.b = 3;</div><div class="line">myObject.b; // undefined</div></pre></td></tr></table></figure>
<p>在非<code>strict mode</code>模式下，<code>b</code>的创建无声地失效；在<code>strict mode</code>模式下，会抛出<code>TypeError</code>。</p>
<h4 id="封印（Seal）"><a href="#封印（Seal）" class="headerlink" title="封印（Seal）"></a>封印（Seal）</h4><p><code>Object.seal(...)</code>创建一个封印对象，相当于在实质上调用<code>Object.preventExtensions(...)</code>的同时，将它所有既存属性标记为<code>configurable:false</code>。</p>
<p>因此，既不能添加属性，也不能重新配置或删除既存属性（虽然你依然 <em>可以</em> 修改它们的值）。</p>
<h4 id="（？）冻结（Freeze）"><a href="#（？）冻结（Freeze）" class="headerlink" title="（？）冻结（Freeze）"></a>（？）冻结（Freeze）</h4><p><code>Object.freeze(..)</code> 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 <code>Object.seal(..)</code>，同时也将它所有的“数据访问”属性设置为 <code>writable:false</code>，所以它们的值不可改变。</p>
<p>这种方法是你可以从对象自身获得的最高级别的不可变性，因为它阻止任何对对象或对象直属属性的改变（虽然，就像上面提到的，任何被引用的对象的内容不受影响）。</p>
<p>你可以“深度冻结”一个对象：在这个对象上调用 <code>Object.freeze(..)</code>，然后递归地迭代所有它引用的（目前还没有受过影响的）对象，然后也在它们上面调用 <code>Object.freeze(..)</code>。但是要小心，这可能会影响其他你并不打算影响的（共享的）对象。</p>
<h4 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h4><p>关于属性访问如何工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a; // 2</div></pre></td></tr></table></figure>
<p>根据语言规范，上面的代码实际上在 <code>myObject</code> 上执行了一个 <code>[[Get]]</code> 操作（有些像 <code>[[Get]]()</code> 函数调用）。对一个对象进行默认的内建 <code>[[Get]]</code> 操作，首先检查对象，寻找一个拥有被请求的名称的属性，如果找到，就返回相应的值。</p>
<p>然而，如果按照被请求的名称 <em>没能</em> 找到属性，<code>[[Get]]</code> 的算法定义了另一个重要的行为。遍历 <code>[[Prototype]]</code> 链，如果有的话。</p>
<p>但 <code>[[Get]]</code> 操作的一个重要结果是，如果它通过任何方法都不能找到被请求的属性的值，那么它会返回 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.b; // undefined</div></pre></td></tr></table></figure>
<p>这个行为和你通过标识符名称来引用 <em>变量</em> 不同。如果你引用了一个在可用的词法作用域内无法解析的变量，其结果不是像对象属性那样返回 <code>undefined</code>，而是抛出一个 <code>ReferenceError</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: undefined</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a; // undefined</div><div class="line"></div><div class="line">myObject.b; // undefined</div></pre></td></tr></table></figure>
<p>从 <em>值</em> 的角度来说，这两个引用没有区别 —— 它们的结果都是 <code>undefined</code>。然而，在 <code>[[Get]]</code> 操作的底层，虽然不明显，但是比起处理引用 <code>myObject.a</code>，处理 <code>myObject.b</code> 的操作要多做一些潜在的“工作”。</p>
<p>如果仅仅考察结果的值，你无法分辨一个属性是存在并持有一个 <code>undefined</code> 值，还是因为属性根本 <em>不</em> 存在所以 <code>[[Get]]</code> 无法返回某个具体值而返回默认的 <code>undefined</code>。但是，你很快就能看到你其实 <em>可以</em> 分辨这两种场景。</p>
<h4 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h4><p>它和[[Get]]是存在微妙不同的：</p>
<p>调用 <code>[[Put]]</code> 时，它根据几个因素表现不同的行为，包括（影响最大的）属性是否已经在对象中存在了。</p>
<p>如果属性存在，<code>[[Put]]</code> 算法将会大致检查：</p>
<ol>
<li>这个属性是访问器描述符吗（见下一节”Getters 与 Setters”）？<strong>如果是，而且是 setter，就调用 setter。</strong></li>
<li>这个属性是 <code>writable</code> 为 <code>false</code> 数据描述符吗？<strong>如果是，在非 strict mode 下无声地失败，或者在 strict mode 下抛出 TypeError。</strong></li>
<li>否则，像平常一样设置既存属性的值。</li>
</ol>
<p>如果属性在当前的对象中还不存在，<code>[[Put]]</code> 操作会变得更微妙和复杂。我们将在第五章讨论 <code>[[Prototype]]</code> 时再次回到这个场景，更清楚地解释它。</p>
<h4 id="Getters与Setters"><a href="#Getters与Setters" class="headerlink" title="Getters与Setters"></a>Getters与Setters</h4><p>Getter：调用一个隐藏函数来取得值的属性；Setter：调用一个隐藏函数来设置值的属性。</p>
<p>当一个属性被定义为拥有getter或setter，那么它们的定义就成了“访问描述符”（与“数据描述符”相对）。</p>
<p>访问描述符的 <code>value</code> 和 <code>writable</code> 性质因没有意义而被忽略，取而代之的是 JS 将会考虑属性的 <code>set</code> 和 <code>get</code> 性质（还有 <code>configurable</code> 和 <code>enumerable</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	// 为 `a` 定义一个 getter</div><div class="line">	get a() &#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.defineProperty(</div><div class="line">	myObject,	// 目标对象</div><div class="line">	&quot;b&quot;,		// 属性名</div><div class="line">	&#123;			// 描述符</div><div class="line">		// 为 `b` 定义 getter</div><div class="line">		get: function()&#123; return this.a * 2 &#125;,</div><div class="line"></div><div class="line">		// 确保 `b` 作为对象属性出现</div><div class="line">		enumerable: true</div><div class="line">	&#125;</div><div class="line">);</div><div class="line"></div><div class="line">myObject.a; // 2</div><div class="line"></div><div class="line">myObject.b; // 4</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	// 为 `a` 定义 getter</div><div class="line">	get a() &#123;</div><div class="line">		return 2;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a = 3;</div><div class="line"></div><div class="line">myObject.a; // 2   没有定义setter，赋值操作无意义</div></pre></td></tr></table></figure>
<p>定义setter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	// 为 `a` 定义 getter</div><div class="line">	get a() &#123;</div><div class="line">		return this._a_;   // _a_ 只是例子中的单纯惯例，无特别之处</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	// 为 `a` 定义 setter</div><div class="line">	set a(val) &#123;</div><div class="line">		this._a_ = val * 2; </div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a = 2;</div><div class="line"></div><div class="line">myObject.a; // 4</div></pre></td></tr></table></figure>
<h3 id="存在性（Existence）"><a href="#存在性（Existence）" class="headerlink" title="存在性（Existence）"></a>存在性（Existence）</h3><p> <code>myObject.a</code> 属性访问会得到一个<code>undefined</code>值，怎么区别它是存储着<code>undefined</code>还是没有被定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">(&quot;a&quot; in myObject);	// true  检查属性是否存在对象中</div><div class="line">(&quot;b&quot; in myObject);	// false</div><div class="line"></div><div class="line">myObject.hasOwnProperty( &quot;a&quot; );	// true 仅检查·myObject·是否拥有属性，不会查询 [[Prototype]]链</div><div class="line">myObject.hasOwnProperty( &quot;b&quot; );	// false</div></pre></td></tr></table></figure>
<p>对于第二种方式更健壮的方式：</p>
<p><code>object.prototype.hasOwnProperty.call(myObject,&quot;a&quot;)</code></p>
<h4 id="枚举（Enumeration）"><a href="#枚举（Enumeration）" class="headerlink" title="枚举（Enumeration）"></a>枚举（Enumeration）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123; &#125;;</div><div class="line"></div><div class="line">Object.defineProperty(</div><div class="line">	myObject,</div><div class="line">	&quot;a&quot;,</div><div class="line">	// 使 `a` 可枚举，如一般情况</div><div class="line">	&#123; enumerable: true, value: 2 &#125;</div><div class="line">);</div><div class="line"></div><div class="line">Object.defineProperty(</div><div class="line">	myObject,</div><div class="line">	&quot;b&quot;,</div><div class="line">	// 使 `b` 不可枚举</div><div class="line">	&#123; enumerable: false, value: 3 &#125;</div><div class="line">);</div><div class="line"></div><div class="line">myObject.b; // 3</div><div class="line">(&quot;b&quot; in myObject); // true    注意！！</div><div class="line">myObject.hasOwnProperty( &quot;b&quot; ); // true</div><div class="line"></div><div class="line">// .......</div><div class="line"></div><div class="line">for (var k in myObject) &#123;   // for...in循环来遍历对象中的属性</div><div class="line">	console.log( k, myObject[k] );   </div><div class="line">&#125;</div><div class="line">// &quot;a&quot; 2  </div><div class="line">// 因为 “enumerable” 基本上意味着“如果对象的属性被迭代时会被包含在内”。</div></pre></td></tr></table></figure>
<p>另一个可以区分可枚举和不可枚举属性的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123; &#125;;</div><div class="line"></div><div class="line">Object.defineProperty(</div><div class="line">	myObject,</div><div class="line">	&quot;a&quot;,</div><div class="line">	// 使 `a` 可枚举，如一般情况</div><div class="line">	&#123; enumerable: true, value: 2 &#125;</div><div class="line">);</div><div class="line"></div><div class="line">Object.defineProperty(</div><div class="line">	myObject,</div><div class="line">	&quot;b&quot;,</div><div class="line">	// 使 `b` 不可枚举</div><div class="line">	&#123; enumerable: false, value: 3 &#125;</div><div class="line">);</div><div class="line"></div><div class="line">myObject.propertyIsEnumerable( &quot;a&quot; ); // true</div><div class="line">myObject.propertyIsEnumerable( &quot;b&quot; ); // false</div><div class="line"></div><div class="line">Object.keys( myObject ); // [&quot;a&quot;]</div><div class="line">Object.getOwnPropertyNames( myObject ); // [&quot;a&quot;, &quot;b&quot;]</div></pre></td></tr></table></figure>
<h2 id="（-）迭代（Iteration）"><a href="#（-）迭代（Iteration）" class="headerlink" title="（*）迭代（Iteration）"></a>（*）迭代（Iteration）</h2><p> 几种迭代方法：</p>
<p><code>forEach(...)</code>：用于迭代数组中的值，忽略回调返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myArray = [1, 2, 3];</div><div class="line"></div><div class="line">myArray.forEach(function (item) &#123;</div><div class="line">	console.log(item);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>every(...)</code>：一直迭代到最后，或回调返回一个<code>false</code>值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const isBiggerThan10 = (element, index, array) =&gt; &#123;</div><div class="line">	return element &gt; 10;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[1,23,3,4,5].every(isBiggerThan10);      // false </div><div class="line">[11,12,13,14].every(isBiggerThan10);     // true</div></pre></td></tr></table></figure>
<p><code>some(...)</code>：一直迭代到最后，或回调返回一个<code>true</code>值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const isBiggerThan10 = (element, index, array) =&gt; &#123;</div><div class="line">	return element &gt; 10;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[1,23,3,4,5].some(isBiggerThan10);   // true</div><div class="line">[1,2,3,4,5].some(isBiggerThan10);    // false</div></pre></td></tr></table></figure>
<p><code>for...of</code>循环：<strong>用来迭代数组和有迭代器的对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var myArray = [1,2,3,4];</div><div class="line">for (var v of myArray) &#123;</div><div class="line">	console.log(v);</div><div class="line">&#125;   // 用来迭代数组和带迭代器的对象</div></pre></td></tr></table></figure>
<p>关于迭代器<code>@@iterator</code>它本身不是迭代器对象，而是一个返回迭代器对象的<strong>方法</strong>：</p>
<p>数组中拥有内建的迭代器。对象中没有。</p>
<p>使用内建的<code>@@iterator</code>手动迭代数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myArray = [ 1, 2, 3 ];</div><div class="line">var it = myArray[Symbol.iterator]();   // Symbol为ES6中</div><div class="line"></div><div class="line">it.next(); // &#123; value:1, done:false &#125;</div><div class="line">it.next(); // &#123; value:2, done:false &#125;</div><div class="line">it.next(); // &#123; value:3, done:false &#125;</div><div class="line">it.next(); // &#123; done:true &#125;   // 使自己知道迭代已完成</div></pre></td></tr></table></figure>
<p>为想要的迭代对象定义自己的默认<code>@@iterator</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2,</div><div class="line">	b: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.defineProperty( myObject, Symbol.iterator, &#123;</div><div class="line">	enumerable: false,</div><div class="line">	writable: false,</div><div class="line">	configurable: true,</div><div class="line">	value: function() &#123;</div><div class="line">		var o = this;</div><div class="line">		var idx = 0;</div><div class="line">		var ks = Object.keys( o );</div><div class="line">		return &#123;</div><div class="line">			next: function() &#123;</div><div class="line">				return &#123;</div><div class="line">					value: o[ks[idx++]],</div><div class="line">					done: (idx &gt; ks.length)</div><div class="line">				&#125;;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// 手动迭代 `myObject`</div><div class="line">var it = myObject[Symbol.iterator]();</div><div class="line">it.next(); // &#123; value:2, done:false &#125;</div><div class="line">it.next(); // &#123; value:3, done:false &#125;</div><div class="line">it.next(); // &#123; value:undefined, done:true &#125;</div><div class="line"></div><div class="line">// 用 `for..of` 迭代 `myObject`</div><div class="line">for (var v of myObject) &#123;</div><div class="line">	console.log( v );</div><div class="line">&#125;</div><div class="line">// 2</div><div class="line">// 3</div></pre></td></tr></table></figure>
<p>一个“无穷”迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var randoms = &#123;</div><div class="line">	[Symbol.iterator]: function() &#123;</div><div class="line">		return &#123;</div><div class="line">			next: function() &#123;</div><div class="line">				return &#123; value: Math.random() &#125;;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var randoms_pool = [];</div><div class="line">for (var n of randoms) &#123;</div><div class="line">	randoms_pool.push( n );</div><div class="line"></div><div class="line">	// 不要超过边界！</div><div class="line">	if (randoms_pool.length === 100) break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第四章：混合（淆）“类”的对象"><a href="#第四章：混合（淆）“类”的对象" class="headerlink" title="第四章：混合（淆）“类”的对象"></a>第四章：混合（淆）“类”的对象</h1><p>讨论：面向对象（oo）编程，类（class）：实例化、继承、多态</p>
<h2 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h2><p>（略）哈哈哈哈哈哈哈哈</p>
<h1 id="第五章：原型（Prototype）"><a href="#第五章：原型（Prototype）" class="headerlink" title="第五章：原型（Prototype）"></a>第五章：原型（Prototype）</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p><code>[[Prototype]]</code>是对象的一个内部属性，它是一个其他对象的引用。对象被创建时，这个属性被赋予了一个非<code>null</code>值。</p>
<p>一个对象拥有一个空的<code>[[Prototype]]</code>链接<strong>是可能的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.a; // 2</div></pre></td></tr></table></figure>
<p><code>myObject.a</code>操作用到了<code>[[Get]]</code>。</p>
<p>第一步：检查对象本身是否有一个<code>a</code>属性，如果有就使用它；</p>
<p>第二步：当没有在对象本身找到时，就沿着<code>[[Prototype]]</code>链继续往下找，直到找到该属性，或者原型链为空返回<code>undefined</code>。</p>
<p>使用<code>[[Prototype]]</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建一个链接到 `anotherObject` 的对象</div><div class="line">var myObject = Object.create( anotherObject );</div><div class="line"></div><div class="line">myObject.a; // 2</div></pre></td></tr></table></figure>
<p>对于<code>for...in</code>循环，它也会像查询一样，枚举链条上可以找到的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 创建一个链接到 `anotherObject` 的对象</div><div class="line">var myObject = Object.create( anotherObject );</div><div class="line"></div><div class="line">for (var k in myObject) &#123;</div><div class="line">	console.log(&quot;found: &quot; + k);</div><div class="line">&#125;</div><div class="line">// 找到: a</div><div class="line"></div><div class="line">(&quot;a&quot; in myObject); // true</div></pre></td></tr></table></figure>
<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a><code>Object.prototype</code></h2><p><code>[[Prototype]]</code>链在<code>Object.prototype</code>处终结，即每个普通的 <code>[[Prototype]]</code> 链的最顶端，是内建的 <code>Object.prototype</code>。</p>
<p>js中所有普通的对象都“衍生自”<code>Object.prototype</code>对象。</p>
<h2 id="设置与遮蔽属性"><a href="#设置与遮蔽属性" class="headerlink" title="设置与遮蔽属性"></a>设置与遮蔽属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myObject.foo = &quot;bar&quot;;</div></pre></td></tr></table></figure>
<p>进行上述操作会出现四种情况：</p>
<p>1、当<code>foo</code>属性<strong>不直接存在</strong>于<code>myObject</code>上，<strong>也不存在</strong>于<code>myObject</code>的<code>[[Prototype]]</code>链的更高层时。<code>foo</code>作为一个新的属性被添加到<code>myObject</code>上。</p>
<p>当 <code>foo</code> <strong>不直接存在</strong> 于 <code>myObject</code>，但 <strong>存在</strong> 于 <code>myObject</code> 的 <code>[[Prototype]]</code> 链的更高层时：</p>
<p>2、如果一个普通的名为 <code>foo</code> 的数据访问属性在 <code>[[Prototype]]</code> 链的高层某处被找到，<strong>而且没有被标记为只读（writable:false）</strong>，那么一个名为 <code>foo</code> 的新属性就直接添加到 <code>myObject</code> 上，形成一个 <strong>遮蔽属性</strong>。</p>
<p>3、如果一个 <code>foo</code> 在 <code>[[Prototype]]</code> 链的高层某处被找到，但是它被标记为 <strong>只读（writable:false）</strong> ，那么设置既存属性和在 <code>myObject</code> 上创建遮蔽属性都是 <strong>不允许</strong> 的。如果代码运行在 <code>strict mode</code> 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，<strong>没有发生遮蔽</strong>。</p>
<p>4、如果一个 <code>foo</code> 在 <code>[[Prototype]]</code> 链的高层某处被找到，而且它是一个 setter（见第三章），那么这个 setter 总是被调用。没有 <code>foo</code> 会被添加到（也就是遮蔽在）<code>myObject</code> 上，这个 <code>foo</code> setter 也不会被重定义。</p>
<p>如果想在第三种和第四种情况下遮蔽<code>foo</code>，就不能使用<code>=</code>赋值，而使用<code>Object.defineProperty(...)</code>将<code>foo</code>添加到<strong><code>myObject</code></strong>。</p>
<p>注意下面这一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myObject = Object.create( anotherObject );</div><div class="line"></div><div class="line">anotherObject.a; // 2</div><div class="line">myObject.a; // 2</div><div class="line"></div><div class="line">anotherObject.hasOwnProperty( &quot;a&quot; ); // true</div><div class="line">myObject.hasOwnProperty( &quot;a&quot; ); // false</div><div class="line"></div><div class="line">myObject.a++; // 噢，隐式遮蔽！</div><div class="line"></div><div class="line">anotherObject.a; // 2</div><div class="line">myObject.a; // 3</div><div class="line"></div><div class="line">myObject.hasOwnProperty( &quot;a&quot; ); // true</div></pre></td></tr></table></figure>
<h2 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h2><h3 id="“类函数”"><a href="#“类函数”" class="headerlink" title="“类函数”"></a>“类函数”</h3><p>在js中，所有的函数默认都会得到一个公有的，不可枚举的属性，称为<code>prototype</code>，它可以指向任意的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	console.log(&apos;hello&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype; // &#123;constructor: ƒ&#125;  这个对象经常被称为“Foo的原型”。</div><div class="line">			  // 	constructor: f foo()</div><div class="line">			  //	_proto_: Object</div></pre></td></tr></table></figure>
<p>每个由调用<code>new Foo()</code>而创建的对象将最终被<code>[[Prototype]]</code>链接到这个<code>Foo.prototype</code>对象。</p>
<p>即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	// ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new Foo();</div><div class="line"></div><div class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</div></pre></td></tr></table></figure>
<p>通过<code>new Foo()</code>创建<code>a</code>时，发生的事情之一是<code>a</code>得到一个内部<code>[[Prototype]]</code>链接，此链接链到<code>Foo.prototype</code>所指向的对象。</p>
<p><strong>所以我们可以看到，在<code>new Foo()</code>这一过程我们并没有做任何从一个类到一个实体对象的拷贝，我们只是将两个对象互相链接在了一起。</strong></p>
<h2 id="“构造器”（Constructors）"><a href="#“构造器”（Constructors）" class="headerlink" title="“构造器”（Constructors）"></a>“构造器”（Constructors）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	// ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.constructor === Foo; // true</div><div class="line"></div><div class="line">var a = new Foo();</div><div class="line">a.constructor === Foo; // true</div></pre></td></tr></table></figure>
<p><code>Foo.prototype</code>对象默认得到一个公有的<code>.constructor</code>属性，这个属性是不可枚举的并且指向<code>Foo</code>。</p>
<p><code>a.constructor === Foo;</code>虽然为<code>true</code>，但<code>a</code>并没有拥有<code>.constructor</code>。</p>
<h3 id="构造器还是调用？"><a href="#构造器还是调用？" class="headerlink" title="构造器还是调用？"></a>构造器还是调用？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function NothingSpecial() &#123;</div><div class="line">	console.log( &quot;Don&apos;t mind me!&quot; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new NothingSpecial();</div><div class="line">// &quot;Don&apos;t mind me!&quot;</div><div class="line"></div><div class="line">a; // NothingSpecial &#123;&#125;</div></pre></td></tr></table></figure>
<p>结论：函数自身不是构造器，当且仅当被<code>new</code>调用时，函数调用是一个“构造器调用”。</p>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Foo(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.myName = function() &#123;</div><div class="line">	return this.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Foo( &quot;a&quot; );</div><div class="line">var b = new Foo( &quot;b&quot; );</div><div class="line"></div><div class="line">a.myName(); // &quot;a&quot;</div><div class="line">b.myName(); // &quot;b&quot;</div></pre></td></tr></table></figure>
<p>分析：</p>
<p><code>a</code>和<code>b</code>的创建：通过<code>new</code>将<code>Foo</code>中的<code>this</code>分别绑定到<code>a</code>和<code>b</code>上，因此在<code>a</code>和<code>b</code>上分别添加了<code>name</code>属性。</p>
<p>两个返回值：根据<code>a</code>和<code>b</code>创建的原理可知，他们都被链接到了<code>Foo.prototype</code> 上，所以根据<code>[[Get]]</code>的原理，会得到“a”和”b“这两个输出值。</p>
<h3 id="复活“构造器”"><a href="#复活“构造器”" class="headerlink" title="复活“构造器”"></a>复活“构造器”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123; /* .. */ &#125;</div><div class="line"></div><div class="line">Foo.prototype = &#123;</div><div class="line">	construcor: &quot;hello&quot;</div><div class="line">&#125;;    // 创建一个新的 prototype 对象</div><div class="line"></div><div class="line">var a1 = new Foo();</div><div class="line">a1.constructor === Foo; // false!</div><div class="line">a1.constructor === Object; // true!</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>首先我们要明白：默认的<code>Foo.prototype</code>中，含有一个<code>constructor: f Foo()</code>。</p>
<p>所以，当我们运行<code>a1.constructor === Foo;</code>时，并不是<code>a1</code>中含有<code>construtor</code>这个属性而是根据<code>[[Get]]</code>在<code>Foo.prototype</code>中得到。</p>
<p>然后通过新建对象，改变了<code>constructor</code>的值。</p>
<p>因此当运行<code>a1.constructor === Object;</code>会返回<code>true</code>，因为根据<code>[[Get]]</code>的原理，我们会在<code>Object.prototype</code>中找到<code>constructor: Object</code>。</p>
<p><strong>误解，消除！</strong></p>
<p>将 <code>.constructor</code> 加回到 <code>Foo.prototype</code> 对象上，并且具有原生行为中的不可枚举性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123; /* .. */ &#125;</div><div class="line"></div><div class="line">Foo.prototype = &#123; /* .. */ &#125;; // 创建一个新的 prototype 对象</div><div class="line"></div><div class="line">// 需要正确地“修复”丢失的 `.construcor`</div><div class="line">// 新对象上的属性以 `Foo.prototype` 的形式提供。</div><div class="line">// `defineProperty(..)` 的内容见第三章。</div><div class="line">Object.defineProperty( Foo.prototype, &quot;constructor&quot; , &#123;</div><div class="line">	enumerable: false,</div><div class="line">	writable: true,</div><div class="line">	configurable: true,</div><div class="line">	value: Foo    // 使 `.constructor` 指向 `Foo`</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h2 id="“（原型）继承”"><a href="#“（原型）继承”" class="headerlink" title="“（原型）继承”"></a>“（原型）继承”</h2><p><img src="https://github.com/getify/You-Dont-Know-JS/raw/1ed-zh-CN/this%20%26%20object%20prototypes/fig3.png" alt="img"></p>
<p>完成上述图中链接方式的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function Foo(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.myName = function() &#123;</div><div class="line">	return this.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Bar(name,label) &#123;</div><div class="line">	Foo.call( this, name );</div><div class="line">	this.label = label;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`</div><div class="line">Bar.prototype = Object.create( Foo.prototype );</div><div class="line"></div><div class="line">// 注意！现在 `Bar.prototype.constructor` 不存在了，</div><div class="line">// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。</div><div class="line"></div><div class="line">Bar.prototype.myLabel = function() &#123;</div><div class="line">	return this.label;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Bar( &quot;a&quot;, &quot;obj a&quot; );</div><div class="line"></div><div class="line">a.myName(); // &quot;a&quot;</div><div class="line">a.myLabel(); // &quot;obj a&quot;</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>通过<code>Bar.prototype = Object.create( Foo.prototype );</code>创建一个<strong>新的</strong><code>Bar.prototype</code>链接到<code>Foo.prototype</code>，并将原来错误的链对象扔掉。</p>
<p>下面两种方法也能工作，但和预期的不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 不会如你期望的那样工作!</div><div class="line">Bar.prototype = Foo.prototype;</div><div class="line"></div><div class="line">// 会如你期望的那样工作</div><div class="line">// 但会带有你可能不想要的副作用 :(</div><div class="line">Bar.prototype = new Foo();</div></pre></td></tr></table></figure>
<p>分析：</p>
<p>第一种方式：是将<code>Bar</code>直接连接到<code>Foo.prototype</code>上，而不是将<code>Bar.prototype</code>链接到<code>Foo.prototype</code>上，所以当运行 <code>Bar.prototype.myLabel = ...</code>时，实际上是修改的<code>Foo.prototype</code>对象本身。</p>
<p>第二种方式：利用构造器链接就很容易出现，<code>Foo()</code>中的<code>this</code>被绑定到了<code>Bar.prototype</code>这种情况。</p>
<p>对比ES6 之前和 ES6 标准的技术如何处理将 <code>Bar.prototype</code> 链接至 <code>Foo.prototype</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES6 以前</div><div class="line">// 扔掉默认既存的 `Bar.prototype`</div><div class="line">Bar.prototype = Object.create( Foo.prototype );</div><div class="line"></div><div class="line">// ES6+</div><div class="line">// 修改既存的 `Bar.prototype`</div><div class="line">Object.setPrototypeOf( Bar.prototype, Foo.prototype );</div></pre></td></tr></table></figure>
<h3 id="考察“类”关系"><a href="#考察“类”关系" class="headerlink" title="考察“类”关系"></a>考察“类”关系</h3><p>主要讨论如何检验两个对象间是否有委托关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	// ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.blah = ...;</div><div class="line"></div><div class="line">var a = new Foo();</div></pre></td></tr></table></figure>
<p>第一种方式：</p>
<p>利用<code>instanceof</code>：<strong><code>instanceof</code></strong> <strong>运算符</strong>用来测试一个对象在其原型链中是否存在一个<strong>构造函数</strong>的 <code>prototype</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a instanceof Foo; // true</div></pre></td></tr></table></figure>
<p>第二种方式：（也是最简洁的方式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Foo.prototype.isPrototypeOf( a ); // true</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 简单地：`b` 在 `c` 的 `[[Prototype]]` 链中出现过吗？</div><div class="line">b.isPrototypeOf( c );</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf( a );</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.__proto__ === Foo.prototype; // true</div></pre></td></tr></table></figure>
<p><code>.__proto__</code>实际上不存在于<code>a</code>上，而是存在于内建的 <code>Object.prototype</code> 上。而且，<code>.__proto__</code> 虽然看起来像一个属性，但实际上将它看做是一个 getter/setter（见第三章）更合适。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty( Object.prototype, &quot;__proto__&quot;, &#123;</div><div class="line">	get: function() &#123;</div><div class="line">		return Object.getPrototypeOf( this );</div><div class="line">	&#125;,</div><div class="line">	set: function(o) &#123;</div><div class="line">		// ES6 的 setPrototypeOf(..)</div><div class="line">		Object.setPrototypeOf( this, o );</div><div class="line">		return o;</div><div class="line">	&#125;</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h2 id="对象链接"><a href="#对象链接" class="headerlink" title="对象链接"></a>对象链接</h2><p>主要讲解<code>Object.create(...)</code>：</p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">	something: function() &#123;</div><div class="line">		console.log( &quot;Tell me something good...&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bar = Object.create( foo );</div><div class="line"></div><div class="line">bar.something(); // Tell me something good...</div></pre></td></tr></table></figure>
<p><code>var bar = Object.create( foo );</code>即创建一个链接到<code>foo</code>上的新对象<code>bar</code>。</p>
<h3 id="填补Object-create"><a href="#填补Object-create" class="headerlink" title="填补Object.create(...)"></a>填补<code>Object.create(...)</code></h3><p>因为<code>Object.create(...)</code>是在ES5中引入的，所以要支持ES5之前的环境，就需要用以下方式来填补：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (!Object.create) &#123;    // 判断是否支持Object.create</div><div class="line">	Object.create = function(o) &#123;</div><div class="line">		function F()&#123;&#125;</div><div class="line">		F.prototype = o; // 将o赋值给F.prototype，所以新创建的函数就会链接到o</div><div class="line">		return new F();</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种不可填补的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	a: 2</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myObject = Object.create( anotherObject, &#123;</div><div class="line">	b: &#123;</div><div class="line">		enumerable: false,</div><div class="line">		writable: true,</div><div class="line">		configurable: false,</div><div class="line">		value: 3</div><div class="line">	&#125;,</div><div class="line">	c: &#123;</div><div class="line">		enumerable: true,</div><div class="line">		writable: false,</div><div class="line">		configurable: false,</div><div class="line">		value: 4</div><div class="line">	&#125;</div><div class="line">&#125; );</div><div class="line"></div><div class="line">myObject.hasOwnProperty( &quot;a&quot; ); // false</div><div class="line">myObject.hasOwnProperty( &quot;b&quot; ); // true</div><div class="line">myObject.hasOwnProperty( &quot;c&quot; ); // true</div><div class="line"></div><div class="line">myObject.a; // 2</div><div class="line">myObject.b; // 3</div><div class="line">myObject.c; // 4</div></pre></td></tr></table></figure>
<p><code>Object.create(..)</code> 的第二个参数通过声明每个新属性的 <em>属性描述符</em>指定了要添加在新对象上的属性。</p>
<p>因为，属性描述符在ES5之前的环境是不可填补的，所以<code>Object.create(..)</code> 这一方法无法填补。</p>
<h3 id="链接作为候补？"><a href="#链接作为候补？" class="headerlink" title="链接作为候补？"></a>链接作为候补？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	cool: function() &#123;</div><div class="line">		console.log( &quot;cool!&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myObject = Object.create( anotherObject );</div><div class="line"></div><div class="line">myObject.cool(); // &quot;cool!&quot;</div></pre></td></tr></table></figure>
<p>如果引用上述方法是将<code>anotherObject</code>作为候补，来访问<code>cool</code>属性，那么上述方式是不提倡的，而应该用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var anotherObject = &#123;</div><div class="line">	cool: function() &#123;</div><div class="line">		console.log( &quot;cool!&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myObject = Object.create( anotherObject );</div><div class="line"></div><div class="line">myObject.doCool = function() &#123;</div><div class="line">	this.cool(); // internal delegation!</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.doCool(); // &quot;cool!&quot;</div></pre></td></tr></table></figure>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p><code>toString()</code>，<code>valueOf()</code>，和其他几种共同工具都存在于这个 <code>Object.prototype</code> 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p>
<p>那个用 <code>new</code> 调用的函数有一个被随便地命名为 <code>.prototype</code> 的属性，这个属性所引用的对象恰好就是这个新对象链接到的“另一个对象”。带有 <code>new</code> 的函数调用通常被称为“构造器”，尽管实际上它们并没有像传统的面向类语言那样初始化一个类。</p>
<h1 id="第六章：行为委托"><a href="#第六章：行为委托" class="headerlink" title="第六章：行为委托"></a>第六章：行为委托</h1><h2 id="迈向面向委托设计"><a href="#迈向面向委托设计" class="headerlink" title="迈向面向委托设计"></a>迈向面向委托设计</h2><h3 id="类理论-1"><a href="#类理论-1" class="headerlink" title="类理论"></a>类理论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Task &#123;</div><div class="line">	id;</div><div class="line"></div><div class="line">	// `Task()` 构造器</div><div class="line">	Task(ID) &#123; id = ID; &#125;</div><div class="line">	outputTask() &#123; output( id ); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class XYZ inherits Task &#123;</div><div class="line">	label;</div><div class="line"></div><div class="line">	// `XYZ()` 构造器</div><div class="line">	XYZ(ID,Label) &#123; super( ID ); label = Label; &#125;  // 利用super来调用这一方法的泛化版本</div><div class="line">	outputTask() &#123; super(); output( label ); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ABC inherits Task &#123;</div><div class="line">	// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个实例都拷贝了完成计划任务的所有行为。所以，在构建完成之后，你通常仅会与这些实例交互。</p>
<h3 id="委托理论"><a href="#委托理论" class="headerlink" title="委托理论"></a>委托理论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var Task = &#123;</div><div class="line">	setID: function(ID) &#123; this.id = ID; &#125;,</div><div class="line">	outputID: function() &#123; console.log( this.id ); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使 `XYZ` 委托到 `Task`</div><div class="line">var XYZ = Object.create( Task );</div><div class="line"></div><div class="line">XYZ.prepareTask = function(ID,Label) &#123;</div><div class="line">	this.setID( ID );</div><div class="line">	this.label = Label;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">XYZ.outputTaskDetails = function() &#123;</div><div class="line">	this.outputID();</div><div class="line">	console.log( this.label );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">XYZ.prepareTask(1, 2);</div><div class="line">XYZ.outputTaskDetails();   // 1 2</div><div class="line"></div><div class="line">// ABC = Object.create( Task );</div><div class="line">// ABC ... = ...</div></pre></td></tr></table></figure>
<p>作为与面向类（OO——面向对象）的对比，我们成上述代码为“OLOO”（链接到其他对象的对象））。</p>
<h4 id="相互委托（不允许）"><a href="#相互委托（不允许）" class="headerlink" title="相互委托（不允许）"></a>相互委托（不允许）</h4><p>你不能在两个或多个对象间相互地委托（双向地）对方来创建一个 <em>循环</em> 。如果你使 <code>B</code> 链接到 <code>A</code>，然后试着让 <code>A</code>链接到 <code>B</code>，那么你将得到一个错误。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javaScript/" rel="tag"><i class="fa fa-tag"></i> javaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/28/You don't know js ( scope & closures ) 学习笔记/" rel="next" title="You don't know js (scope&closures) 学习笔记">
                <i class="fa fa-chevron-left"></i> You don't know js (scope&closures) 学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/17/react-hot-webpack-boilerplate/" rel="prev" title="react-webpack-temple">
                react-webpack-temple <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Shirley" />
          <p class="site-author-name" itemprop="name">Shirley</p>
           
              <p class="site-description motion-element" itemprop="description">Only when you plant the flowers can you really smell their fragrance.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：this是什么？"><span class="nav-number">1.</span> <span class="nav-text">第一章：this是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要用this"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要用this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#困惑"><span class="nav-number">1.2.</span> <span class="nav-text">困惑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#它自己"><span class="nav-number">1.2.1.</span> <span class="nav-text">它自己</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#它的作用域"><span class="nav-number">1.2.2.</span> <span class="nav-text">它的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是this？"><span class="nav-number">1.3.</span> <span class="nav-text">什么是this？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：this豁然开朗"><span class="nav-number">2.</span> <span class="nav-text">第二章：this豁然开朗</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#调用点（Call-site）"><span class="nav-number">2.1.</span> <span class="nav-text">调用点（Call-site）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四种规则"><span class="nav-number">2.2.</span> <span class="nav-text">四种规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认绑定（Default-Binding）"><span class="nav-number">2.2.1.</span> <span class="nav-text">默认绑定（Default Binding）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐含绑定（Implicit-Binding）"><span class="nav-number">2.2.2.</span> <span class="nav-text">隐含绑定（Implicit Binding）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐含丢失（Implicitly-Lost）"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">隐含丢失（Implicitly Lost）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#明确绑定（Explicit-Binding）"><span class="nav-number">2.2.3.</span> <span class="nav-text">明确绑定（Explicit Binding）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬绑定（Hard-Binding）"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">硬绑定（Hard Binding）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-绑定（new-Binding）"><span class="nav-number">2.2.4.</span> <span class="nav-text">new 绑定（new Binding）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一切皆有顺序"><span class="nav-number">2.3.</span> <span class="nav-text">一切皆有顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判定this"><span class="nav-number">2.3.1.</span> <span class="nav-text">判定this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定的特例"><span class="nav-number">2.4.</span> <span class="nav-text">绑定的特例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#被忽略的this"><span class="nav-number">2.4.1.</span> <span class="nav-text">被忽略的this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更安全的this"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">更安全的this</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#间接"><span class="nav-number">2.4.2.</span> <span class="nav-text">间接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软化绑定"><span class="nav-number">2.4.3.</span> <span class="nav-text">软化绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#词法this"><span class="nav-number">2.5.</span> <span class="nav-text">词法this</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章：对象"><span class="nav-number">3.</span> <span class="nav-text">第三章：对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语法"><span class="nav-number">3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型"><span class="nav-number">3.2.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内建对象"><span class="nav-number">3.2.1.</span> <span class="nav-text">内建对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内容"><span class="nav-number">3.3.</span> <span class="nav-text">内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算型属性名"><span class="nav-number">3.3.1.</span> <span class="nav-text">计算型属性名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性vs-方法"><span class="nav-number">3.3.2.</span> <span class="nav-text">属性vs.方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.3.3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（？）复制对象"><span class="nav-number">3.3.4.</span> <span class="nav-text">（？）复制对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性描述符"><span class="nav-number">3.3.5.</span> <span class="nav-text">属性描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可写性（writable"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">可写性（writable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可配置型（Configurable）"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">可配置型（Configurable）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可枚举性（Enumerable）"><span class="nav-number">3.3.5.3.</span> <span class="nav-text">可枚举性（Enumerable）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可变性（Immutability）"><span class="nav-number">3.3.6.</span> <span class="nav-text">不可变性（Immutability）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象常量（Object-Constant）"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">对象常量（Object Constant）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#防止扩展（Prevent-Extensions）"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">防止扩展（Prevent Extensions）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封印（Seal）"><span class="nav-number">3.3.6.3.</span> <span class="nav-text">封印（Seal）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（？）冻结（Freeze）"><span class="nav-number">3.3.6.4.</span> <span class="nav-text">（？）冻结（Freeze）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Get"><span class="nav-number">3.3.6.5.</span> <span class="nav-text">[[Get]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Put"><span class="nav-number">3.3.6.6.</span> <span class="nav-text">[[Put]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Getters与Setters"><span class="nav-number">3.3.6.7.</span> <span class="nav-text">Getters与Setters</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存在性（Existence）"><span class="nav-number">3.3.7.</span> <span class="nav-text">存在性（Existence）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举（Enumeration）"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">枚举（Enumeration）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（-）迭代（Iteration）"><span class="nav-number">3.4.</span> <span class="nav-text">（*）迭代（Iteration）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章：混合（淆）“类”的对象"><span class="nav-number">4.</span> <span class="nav-text">第四章：混合（淆）“类”的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类理论"><span class="nav-number">4.1.</span> <span class="nav-text">类理论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章：原型（Prototype）"><span class="nav-number">5.</span> <span class="nav-text">第五章：原型（Prototype）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Prototype"><span class="nav-number">5.1.</span> <span class="nav-text">[[Prototype]]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype"><span class="nav-number">5.2.</span> <span class="nav-text">Object.prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置与遮蔽属性"><span class="nav-number">5.3.</span> <span class="nav-text">设置与遮蔽属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“类”"><span class="nav-number">5.4.</span> <span class="nav-text">“类”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“类函数”"><span class="nav-number">5.4.1.</span> <span class="nav-text">“类函数”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“构造器”（Constructors）"><span class="nav-number">5.5.</span> <span class="nav-text">“构造器”（Constructors）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器还是调用？"><span class="nav-number">5.5.1.</span> <span class="nav-text">构造器还是调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机制"><span class="nav-number">5.5.2.</span> <span class="nav-text">机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复活“构造器”"><span class="nav-number">5.5.3.</span> <span class="nav-text">复活“构造器”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“（原型）继承”"><span class="nav-number">5.6.</span> <span class="nav-text">“（原型）继承”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#考察“类”关系"><span class="nav-number">5.6.1.</span> <span class="nav-text">考察“类”关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象链接"><span class="nav-number">5.7.</span> <span class="nav-text">对象链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#填补Object-create"><span class="nav-number">5.7.1.</span> <span class="nav-text">填补Object.create(...)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接作为候补？"><span class="nav-number">5.7.2.</span> <span class="nav-text">链接作为候补？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复习"><span class="nav-number">5.8.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章：行为委托"><span class="nav-number">6.</span> <span class="nav-text">第六章：行为委托</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迈向面向委托设计"><span class="nav-number">6.1.</span> <span class="nav-text">迈向面向委托设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类理论-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">类理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托理论"><span class="nav-number">6.1.2.</span> <span class="nav-text">委托理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相互委托（不允许）"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">相互委托（不允许）</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shirley</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共35.3k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  


  

</body>
</html>
