<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="第一章：异步：现在与稍后块儿（Chunks）中的程序仅有一个块儿会在现在执行，其他的将会在稍后执行。最常见的代码块儿单位是function。 异步控制台有些浏览器和某些条件下，consle.log(...)实际上不会立即输出它得到的东西。主要原因可能是I/O处理很慢，而且是许多程序的阻塞部分（不仅是JS）。">
<meta name="keywords" content="javaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="You don&#39;t know js (async &amp; performance) 学习笔记">
<meta property="og:url" content="http:/four27.com/2017/10/09/You don't know js ( async & performance ) 学习笔记/index.html">
<meta property="og:site_name" content="Shirley&#39;s Blog">
<meta property="og:description" content="第一章：异步：现在与稍后块儿（Chunks）中的程序仅有一个块儿会在现在执行，其他的将会在稍后执行。最常见的代码块儿单位是function。 异步控制台有些浏览器和某些条件下，consle.log(...)实际上不会立即输出它得到的东西。主要原因可能是I/O处理很慢，而且是许多程序的阻塞部分（不仅是JS）。">
<meta property="og:updated_time" content="2017-11-16T09:09:28.162Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You don&#39;t know js (async &amp; performance) 学习笔记">
<meta name="twitter:description" content="第一章：异步：现在与稍后块儿（Chunks）中的程序仅有一个块儿会在现在执行，其他的将会在稍后执行。最常见的代码块儿单位是function。 异步控制台有些浏览器和某些条件下，consle.log(...)实际上不会立即输出它得到的东西。主要原因可能是I/O处理很慢，而且是许多程序的阻塞部分（不仅是JS）。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http:/four27.com/2017/10/09/You don't know js ( async & performance ) 学习笔记/"/>





  <title>You don't know js (async & performance) 学习笔记 | Shirley's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shirley's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:/four27.com/2017/10/09/You don't know js ( async & performance ) 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">You don't know js (async & performance) 学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T08:49:21+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：异步：现在与稍后"><a href="#第一章：异步：现在与稍后" class="headerlink" title="第一章：异步：现在与稍后"></a>第一章：异步：现在与稍后</h1><h2 id="块儿（Chunks）中的程序"><a href="#块儿（Chunks）中的程序" class="headerlink" title="块儿（Chunks）中的程序"></a>块儿（Chunks）中的程序</h2><p>仅有一个块儿会在现在执行，其他的将会在稍后执行。最常见的代码块儿单位是<code>function</code>。</p>
<h3 id="异步控制台"><a href="#异步控制台" class="headerlink" title="异步控制台"></a>异步控制台</h3><p>有些浏览器和某些条件下，<code>consle.log(...)</code>实际上不会立即输出它得到的东西。主要原因可能是I/O处理很慢，而且是许多程序的阻塞部分（不仅是JS）。</p>
<a id="more"></a>
<h2 id="事件轮询（Event-Loop）"><a href="#事件轮询（Event-Loop）" class="headerlink" title="事件轮询（Event Loop）"></a>事件轮询（Event Loop）</h2><p>什么是事件轮询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// `eventLoop`是一个像队列一样的数组（先进先出）</div><div class="line">var eventLoop = [ ];</div><div class="line">var event;</div><div class="line"></div><div class="line">// “永远”执行</div><div class="line">while (true) &#123;</div><div class="line">	// 执行一个&quot;tick&quot;</div><div class="line">	if (eventLoop.length &gt; 0) &#123;</div><div class="line">		// 在队列中取得下一个事件</div><div class="line">		event = eventLoop.shift();</div><div class="line"></div><div class="line">		// 现在执行下一个事件</div><div class="line">		try &#123;</div><div class="line">			event();</div><div class="line">		&#125;</div><div class="line">		catch (err) &#123;</div><div class="line">			reportError(err);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，有一个通过<code>while</code>循环来表现的持续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的函数回调。</p>
<p>对于<code>setTimeout(...)</code>不会将回调放在事件轮询队列上，它设置一个定时器，当这个定时器超时的时候，环境才会把你的回调放进事件轮询，这样在某个未来的某个tick中它将会将被取出执行。这就是它不会在你指定的时间间隔内准时触发。</p>
<h2 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h2><p>不同处理器上，或不同计算机上，多个线程可以共享一个进程的内存资源，这些线程可以独立地<strong>同时执行</strong>。这就是并行线程。</p>
<p>并行线程执行的穿插，与异步事件的穿插发生在完全不同的粒度等级上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var a = 20;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	a = a + 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	a = a * 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是一个给定的库中的随意Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<p>异步事件的穿插是以代码块为单位，而并行线程是以每一个线程上执行的一步操作为单位，如：<code>a = a * 2</code>，可以分为读取当前<code>a</code>的值、再把<code>2</code>放在某个地方、然后进行乘法计算、最后把结果存回到<code>a</code>。这就可以由不同的线程执行。</p>
<p>在同一个程序中有两个不同的线程，就有可能得到无法预测的结果。</p>
<p>线程1（<code>X</code>和<code>Y</code>是临时的内存位置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo():</div><div class="line">	a. 将`a`的值读取到`X`</div><div class="line">	b. 将`1`存入`Y`</div><div class="line">	c. 把`X`和`Y`相加，将结果存入`X`</div><div class="line">  d. 将`X`的值存入`a`</div></pre></td></tr></table></figure>
<p>线程2（<code>X</code>和<code>Y</code>是临时的内存位置）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bar():</div><div class="line">  a. 将`a`的值读取到`X`</div><div class="line">	b. 将`2`存入`Y`</div><div class="line">	c. 把`X`和`Y`相乘，将结果存入`X`</div><div class="line">	d. 将`X`的值存入`a`</div></pre></td></tr></table></figure>
<p>现在，让我们假定这两个线程在并行执行。你可能发现了问题，对吧？它们在临时的步骤中使用共享的内存位置<code>X</code>和<code>Y</code>。</p>
<p>如果步骤像这样发生，<code>a</code>的最终结果什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1a  (将`a`的值读取到`X`   ==&gt; `20`)</div><div class="line">2a  (将`a`的值读取到`X`   ==&gt; `20`)</div><div class="line">1b  (将`1`存入`Y`   ==&gt; `1`)</div><div class="line">2b  (将`2`存入`Y`   ==&gt; `2`)</div><div class="line">1c  (把`X`和`Y`相加，将结果存入`X`   ==&gt; `22`)</div><div class="line">1d  (将`X`的值存入`a`   ==&gt; `22`)</div><div class="line">2c  (把`X`和`Y`相乘，将结果存入`X`   ==&gt; `44`)</div><div class="line">2d  (将`X`的值存入`a`   ==&gt; `44`)</div></pre></td></tr></table></figure>
<p><code>a</code>中的结果将是<code>44</code>。那么这种顺序呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1a  (将`a`的值读取到`X`   ==&gt; `20`)</div><div class="line">2a  (将`a`的值读取到`X`   ==&gt; `20`)</div><div class="line">2b  (将`2`存入`Y`   ==&gt; `2`)</div><div class="line">1b  (将`1`存入`Y`   ==&gt; `1`)</div><div class="line">2c  (把`X`和`Y`相乘，将结果存入`X`   ==&gt; `20`)</div><div class="line">1c  (把`X`和`Y`相加，将结果存入`X`   ==&gt; `21`)</div><div class="line">1d  (将`X`的值存入`a`   ==&gt; `21`)</div><div class="line">2d  (将`X`的值存入`a`   ==&gt; `21`)</div></pre></td></tr></table></figure>
<p><code>a</code>中的结果将是<code>21</code>。</p>
<p><strong>但javascript从不跨线程共享数据！！！</strong></p>
<h3 id="运行至完成"><a href="#运行至完成" class="headerlink" title="运行至完成"></a>运行至完成</h3><p><strong>javaScript是单线程的。</strong></p>
<p><code>foo()</code>（和<code>bar()</code>）中的代码是原子性的，这意味着一旦<code>foo()</code>开始运行，它的全部代码都会在<code>bar()</code>中的任何代码可以运行之前执行完成，反之亦然。这称为“运行至完成”行为。</p>
<p>但即使是这样，异步事件仍然会造成结果的不确定。因为我们无法确定上述的<code>foo</code>和<code>bar</code>到底哪一个块儿会先执行。这种函数顺序的不确定性通常称为“竞合状态”（竞争者和<code>a</code>合作，哈哈哈，个人乱解）。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发是当两个或多个“进程”在<strong>同一时间段内</strong>同时执行。</p>
<p>栗子：第一个“进程”将响应当用户向下滚动页面时触发的<code>onscroll</code>事件（发起取得新内容的Ajax请求）。第二个“进程”将接收返回的Ajax应答（将内容绘制在页面上）。</p>
<p>注意：这里的<code>onscroll</code>事件进程其实是操作系统的一个任务。</p>
<p>“线程”1 (<code>onscroll</code>事件):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">onscroll, request 1</div><div class="line">onscroll, request 2</div><div class="line">onscroll, request 3</div><div class="line">onscroll, request 4</div><div class="line">onscroll, request 5</div><div class="line">onscroll, request 6</div><div class="line">onscroll, request 7</div></pre></td></tr></table></figure>
<p>“线程”2 (Ajax应答事件):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">response 1</div><div class="line">response 2</div><div class="line">response 3</div><div class="line">response 4</div><div class="line">response 5</div><div class="line">response 6</div><div class="line">response 7</div></pre></td></tr></table></figure>
<p>一个<code>onscroll</code>事件与一个Ajax应答事件很有可能在同一个 <em>时刻</em> 都准备好被处理了。比如我们在一个时间线上描绘一下这些事件的话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">onscroll, request 1</div><div class="line">onscroll, request 2          response 1</div><div class="line">onscroll, request 3          response 2</div><div class="line">response 3</div><div class="line">onscroll, request 4</div><div class="line">onscroll, request 5</div><div class="line">onscroll, request 6          response 4</div><div class="line">onscroll, request 7</div><div class="line">response 6</div><div class="line">response 5</div><div class="line">response 7</div></pre></td></tr></table></figure>
<p>但js一次只能处理一个时间，所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">onscroll, request 1   &lt;--- 进程1开始</div><div class="line">onscroll, request 2</div><div class="line">response 1            &lt;--- 进程2开始</div><div class="line">onscroll, request 3</div><div class="line">response 2</div><div class="line">response 3</div><div class="line">onscroll, request 4</div><div class="line">onscroll, request 5</div><div class="line">onscroll, request 6</div><div class="line">response 4</div><div class="line">onscroll, request 7   &lt;--- 进程1结束</div><div class="line">response 6</div><div class="line">response 5</div><div class="line">response 7            &lt;--- 进程2结束</div></pre></td></tr></table></figure>
<h3 id="非互动"><a href="#非互动" class="headerlink" title="非互动"></a>非互动</h3><p>任务间无联系，就无互动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var res = &#123;&#125;;</div><div class="line"></div><div class="line">function foo(results) &#123;</div><div class="line">	res.foo = results;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(results) &#123;</div><div class="line">	res.bar = results;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<p>这不是一个“竞合状态”Bug，因为这段代码总能够正确工作，与顺序无关。</p>
<h3 id="互动"><a href="#互动" class="headerlink" title="互动"></a>互动</h3><p>并发进程间有互动，需要协调互动行为防止“竞合状态”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var res = [];</div><div class="line"></div><div class="line">function response(data) &#123;</div><div class="line">	res.push( data );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, response );</div><div class="line">ajax( &quot;http://some.url.2&quot;, response );</div></pre></td></tr></table></figure>
<p>由于请求资源的不同，两次ajax请求返回结果存储在res中的顺序可能有不同。这种不确定性是一个“竞合状态”Bug。</p>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var res = [];</div><div class="line"></div><div class="line">function response(data) &#123;</div><div class="line">	if (data.url == &quot;http://some.url.1&quot;) &#123;</div><div class="line">		res[0] = data;</div><div class="line">	&#125;</div><div class="line">	else if (data.url == &quot;http://some.url.2&quot;) &#123;</div><div class="line">		res[1] = data;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, response );</div><div class="line">ajax( &quot;http://some.url.2&quot;, response );</div></pre></td></tr></table></figure>
<p>竞合状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var a, b;</div><div class="line"></div><div class="line">function foo(x) &#123;</div><div class="line">	a = x * 2;</div><div class="line">	baz();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(y) &#123;</div><div class="line">	b = y * 2;</div><div class="line">	baz();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function baz() &#123;</div><div class="line">	console.log(a + b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var a, b;</div><div class="line"></div><div class="line">function foo(x) &#123;</div><div class="line">	a = x * 2;</div><div class="line">	if (a &amp;&amp; b) &#123;   </div><div class="line">		baz();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(y) &#123;</div><div class="line">	b = y * 2;</div><div class="line">	if (a &amp;&amp; b) &#123;</div><div class="line">		baz();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function baz() &#123;</div><div class="line">	console.log( a + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<p><code>baz()</code>调用周围的<code>if (a &amp;&amp; b)</code>条件通常称为<strong>“大门”</strong>，因为我们不能确定<code>a</code>和<code>b</code>到来的顺序，但在打开大门（调用<code>baz()</code>）之前我们等待它们全部到达。</p>
<p>另一种你可能会遇到的并发互动状态有时称为“竞争”，单更准确地说应该叫<strong>“门闩”</strong>。它的行为特点是“先到者胜”。在这里不确定性是可以接受的，因为你明确指出“竞争”的终点线上只有一个胜利者。</p>
<p>竞合状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line"></div><div class="line">function foo(x) &#123;</div><div class="line">	a = x * 2;</div><div class="line">	baz();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(x) &#123;</div><div class="line">	a = x / 2;</div><div class="line">	baz();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function baz() &#123;</div><div class="line">	console.log( a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<p>解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var a;</div><div class="line"></div><div class="line">function foo(x) &#123;</div><div class="line">	if (a == undefined) &#123;</div><div class="line">		a = x * 2;</div><div class="line">		baz();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(x) &#123;</div><div class="line">	if (a == undefined) &#123;</div><div class="line">		a = x / 2;</div><div class="line">		baz();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function baz() &#123;</div><div class="line">	console.log( a );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, foo );</div><div class="line">ajax( &quot;http://some.url.2&quot;, bar );</div></pre></td></tr></table></figure>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>另一种并发协调的方式称为“协作并发”，他的目标是将一个长时间运作的“进程”打断为许多步骤或批处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var res = [];</div><div class="line"></div><div class="line">// `response(..)`从Ajax调用收到一个结果数组</div><div class="line">function response(data) &#123;</div><div class="line">	// 连接到既存的`res`数组上</div><div class="line">	res = res.concat(</div><div class="line">		// 制造一个新的变形过的数组，所有的`data`值都翻倍</div><div class="line">		data.map( function(val)&#123;</div><div class="line">			return val * 2;</div><div class="line">		&#125; )</div><div class="line">	);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, response );</div><div class="line">ajax( &quot;http://some.url.2&quot;, response );</div></pre></td></tr></table></figure>
<p>协作开发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var res = [];</div><div class="line"></div><div class="line">// `response(..)`从Ajax调用收到一个结果数组</div><div class="line">function response(data) &#123;</div><div class="line">	// 我们一次只处理1000件</div><div class="line">	var chunk = data.splice( 0, 1000 );</div><div class="line"></div><div class="line">	// 连接到既存的`res`数组上</div><div class="line">	res = res.concat(</div><div class="line">		// 制造一个新的变形过的数组，所有的`data`值都翻倍</div><div class="line">		chunk.map( function(val)&#123;</div><div class="line">			return val * 2;</div><div class="line">		&#125; )</div><div class="line">	);</div><div class="line"></div><div class="line">	// 还有东西要处理吗？</div><div class="line">	if (data.length &gt; 0) &#123;</div><div class="line">		// 异步规划下一个批处理</div><div class="line">		setTimeout( function()&#123;</div><div class="line">			response( data );</div><div class="line">		&#125;, 0 );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ajax(..) 是某个包中任意的Ajax函数</div><div class="line">ajax( &quot;http://some.url.1&quot;, response );</div><div class="line">ajax( &quot;http://some.url.2&quot;, response );</div></pre></td></tr></table></figure>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>在ES6中，在事件轮询队列之上引入了一层新概念，称为“工作队列（Job queue）”。</p>
<p>“工作队列”是一个挂靠在事件轮询队列的每个tick末尾的队列。在事件轮询的一个tick期间内，某些可能发生的隐含异步动作的行为将不会导致一个全新的事件加入事件轮询队列，而是在当前tick的工作队列的末尾加入一个新的记录（也就是一个Job）。</p>
<p>或者，用一个比喻：事件轮询队列就像一个游乐园项目，一旦你乘坐完一次，你就不得不去队尾排队来乘坐下一次。而工作队列就像乘坐完后，立即插队乘坐下一次。</p>
<h2 id="语句排序"><a href="#语句排序" class="headerlink" title="语句排序"></a>语句排序</h2><h1 id="第二章：回调"><a href="#第二章：回调" class="headerlink" title="第二章：回调"></a>第二章：回调</h1><h2 id="嵌套-链接的回调"><a href="#嵌套-链接的回调" class="headerlink" title="嵌套/链接的回调"></a>嵌套/链接的回调</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">listen( &quot;click&quot;, function handler(evt)&#123;</div><div class="line">	setTimeout( function request()&#123;</div><div class="line">		ajax( &quot;http://some.url.1&quot;, function response(text)&#123;</div><div class="line">			if (text == &quot;hello&quot;) &#123;</div><div class="line">				handler();</div><div class="line">			&#125;</div><div class="line">			else if (text == &quot;world&quot;) &#123;</div><div class="line">				request();</div><div class="line">			&#125;</div><div class="line">		&#125; );</div><div class="line">	&#125;, 500) ;</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>简化上述代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">listen( &quot;click&quot;, handler );</div><div class="line"></div><div class="line">function handler() &#123;</div><div class="line">	setTimeout( request, 500 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function request()&#123;</div><div class="line">	ajax( &quot;http://some.url.1&quot;, response );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function response(text)&#123;</div><div class="line">	if (text == &quot;hello&quot;) &#123;</div><div class="line">		handler();</div><div class="line">	&#125;</div><div class="line">	else if (text == &quot;world&quot;) &#123;</div><div class="line">		request();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这一过程中出现了硬编码：将第2步硬编码在第1步中，将第3步硬编码在第2步中，将第4步硬编码在第3步中。</p>
<p>但硬编码会使代码边得脆弱因为它不考虑任何可能使在步骤前行的过程中出现偏差的异常情况。举个例子，如果第2步失败了，第3步永远不会到达，第2步也不会重试，或者移动到一个错误处理流程上，等等。</p>
<h1 id="第三章：Promises"><a href="#第三章：Promises" class="headerlink" title="第三章：Promises"></a>第三章：Promises</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><p>下面的栗子展示如何通过<code>Promise</code>来表达<code>x + y</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function add(xPromise,yPromise) &#123;</div><div class="line">	// `Promise.all([ .. ])`接收一个Promise的数组，</div><div class="line">	// 并返回一个等待它们全部完成的新Promise</div><div class="line">	return Promise.all( [xPromise, yPromise] )</div><div class="line"></div><div class="line">	// 当这个Promise被解析后，我们拿起收到的`X`和`Y`的值，并把它们相加</div><div class="line">	.then( function(values)&#123;</div><div class="line">		// `values`是一个从先前被解析的Promise那里收到的消息数组</div><div class="line">		return values[0] + values[1];</div><div class="line">	&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">// `fetchX()`和`fetchY()`分别为它们的值返回一个Promise，</div><div class="line">// 这些值可能在 *现在* 或 *稍后* 准备好</div><div class="line">add( fetchX(), fetchY() )</div><div class="line"></div><div class="line">// 为了将两个数字相加，我们得到一个Promise。</div><div class="line">// 现在我们链式地调用`then(..)`来等待返回的Promise被解析</div><div class="line">.then( function(sum)&#123;</div><div class="line">	console.log( sum ); // 这容易多了！</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在<code>add(..)</code>内部。<code>Promise.all([ .. ])</code>调用创建了一个promise（它在等待<code>promiseX</code>和<code>promiseY</code>被解析）。链式调用<code>.then(..)</code>创建了另一个promise，它的<code>return values[0] + values[1]</code>这一行会被立即解析（使用加法的结果）。这样，我们链接在<code>add(..)</code>调用末尾的<code>then(..)</code>调用——在代码段最后——实际上是在第二个被返回的promise上进行操作，而非被<code>Promise.all([ .. ])</code>创建的第一个promise。另外，虽然我们没有在这第二个<code>then(..)</code>的末尾链接任何操作，它也已经创建了另一个promise，我们可以选择监听/使用它。这类Promise链的细节将会在本章后面进行讲解。</p>
<p>总的来说：Promise是一种用来包装与组合 <em>未来值</em>，并且可以很容易复用的机制。</p>
<h3 id="完成事件"><a href="#完成事件" class="headerlink" title="完成事件"></a>完成事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	// 开始做一些可能会花一段时间的事情</div><div class="line"></div><div class="line">	// 制造一个`listener`事件通知能力并返回</div><div class="line"></div><div class="line">	return listener;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var evt = foo( 42 );</div><div class="line"></div><div class="line">evt.on( &quot;completion&quot;, function()&#123;</div><div class="line">	// 现在我们可以做下一步了！</div><div class="line">&#125; );</div><div class="line"></div><div class="line">evt.on( &quot;failure&quot;, function(err)&#123;</div><div class="line">	// 噢，在`foo(..)`中有某些事情搞错了</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h4 id="Promise”事件“"><a href="#Promise”事件“" class="headerlink" title="Promise”事件“"></a>Promise”事件“</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo(x) &#123;</div><div class="line">	// 开始做一些可能会花一段时间的事情</div><div class="line"></div><div class="line">	// 构建并返回一个promise</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// 最终需要调用`resolve(..)`或`reject(..)`</div><div class="line">		// 它们是这个promise的解析回调</div><div class="line">	&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = foo( 42 );</div><div class="line"></div><div class="line">bar( p );</div><div class="line"></div><div class="line">baz( p );</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在<code>new Promise( function(..){ .. } )</code>中展示的模式通常被称为<a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/" target="_blank" rel="external">“揭示构造器（revealing constructor）”</a>。<strong>被传入的函数被立即执行</strong>（不会被异步推迟，像<code>then(..)</code>的回调那样），而且它被提供了两个参数，我们叫它们<code>resolve</code>和<code>reject</code>。这些是Promise的解析函数。<code>resolve(..)</code>一般表示完成，而<code>reject(..)</code>表示拒绝。</p>
<p><code>bar(..)</code>和<code>baz(..)</code>的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function bar(fooPromise) &#123;</div><div class="line">	// 监听`foo(..)`的完成</div><div class="line">	fooPromise.then(</div><div class="line">		function()&#123;</div><div class="line">			// `foo(..)`现在完成了，那么做`bar(..)`的任务</div><div class="line">		&#125;,</div><div class="line">		function()&#123;</div><div class="line">			// 噢，在`foo(..)`中有某些事情搞错了</div><div class="line">		&#125;</div><div class="line">	);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// `baz(..)`同上</div></pre></td></tr></table></figure>
<h2 id="Promise的信任"><a href="#Promise的信任" class="headerlink" title="Promise的信任"></a>Promise的信任</h2><h3 id="调的太早"><a href="#调的太早" class="headerlink" title="调的太早"></a>调的太早</h3><h3 id="调的太晚"><a href="#调的太晚" class="headerlink" title="调的太晚"></a>调的太晚</h3><p>同步监听是不可能的，所以不可能有一个同步的任务链的运行来“推迟”另一个回调的发生。也就是说，当一个Promise被解析时，所有在<code>then(..)</code>上注册的回调都将被立即，按顺序地，在下一个异步机会时被调用（再一次，参照第一章的”Jobs”），而且没有任何在这些回调中发生的事情可以影响/推迟其他回调的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">p.then( function()&#123;</div><div class="line">	p.then( function()&#123;</div><div class="line">		console.log( &quot;C&quot; );</div><div class="line">	&#125; );</div><div class="line">	console.log( &quot;A&quot; );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p.then( function()&#123;</div><div class="line">	console.log( &quot;B&quot; );</div><div class="line">&#125; );</div><div class="line">// A B C</div></pre></td></tr></table></figure>
<h4 id="Promise排程的怪现象"><a href="#Promise排程的怪现象" class="headerlink" title="Promise排程的怪现象"></a>Promise排程的怪现象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var p3 = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( &quot;B&quot; );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p1 = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( p3 );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p2 = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( &quot;A&quot; );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p1.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p2.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// A B  &lt;-- 不是你可能期望的 B A</div></pre></td></tr></table></figure>
<p>我们稍后会更多地讲解这个问题，但如你所见，<code>p1</code>不是被一个立即值所解析的，而是由另一个promise<code>p3</code>所解析，而<code>p3</code>本身被一个值<code>&quot;B&quot;</code>所解析。这种指定的行为将<code>p3</code><em>展开</em> 到<code>p1</code>，但是是异步地，所以在异步工作队列中<code>p1</code>的回调位于<code>p2</code>的回调之后（参照第一章的”Jobs”）。</p>
<p>为了回避这样的微妙的噩梦，你绝不应该依靠任何跨Promise的回调顺序/排程。事实上，一个好的实践方式是在代码中根本不要让多个回调的顺序成为问题。尽可能回避它。</p>
<h4 id="可信的Promise"><a href="#可信的Promise" class="headerlink" title="可信的Promise?"></a>可信的Promise?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 不要只是这么做：</div><div class="line">foo( 42 )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// 相反，这样做：</div><div class="line">Promise.resolve( foo( 42 ) )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 将任意函数的返回值（thenable或不是thenable）包装在<code>Promise.resolve(..)</code>中的另一个好的副作用是，它可以很容易地将函数调用泛化为一个行为规范的异步任务。如果<code>foo(42)</code>有时返回一个立即值，而其他时候返回一个Promise，<code>Promise.resolve(foo(42))</code>，将确保它总是返回Promise。并且使代码成为回避Zalgo效应的更好的代码。</p>
<h2 id="Thenable鸭子类型（Duck-Typing）"><a href="#Thenable鸭子类型（Duck-Typing）" class="headerlink" title="Thenable鸭子类型（Duck Typing）"></a>Thenable鸭子类型（Duck Typing）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (</div><div class="line">	p !== null &amp;&amp;</div><div class="line">	(</div><div class="line">		typeof p === &quot;object&quot; ||</div><div class="line">		typeof p === &quot;function&quot;</div><div class="line">	) &amp;&amp;</div><div class="line">	typeof p.then === &quot;function&quot;</div><div class="line">) &#123;</div><div class="line">	// 认为它是一个thenable!</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">	// 不是一个thenable</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="链式流程"><a href="#链式流程" class="headerlink" title="链式流程"></a>链式流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">var p2 = p.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 使用值`42`完成`p2`</div><div class="line">	return v * 2;</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// 在`p2`后链接</div><div class="line">p2.then( function(v)&#123;</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>简单链接之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">p</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 使用值`42`完成被链接的promise</div><div class="line">	return v * 2;</div><div class="line">&#125; )</div><div class="line">// 这里是被链接的promise</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>还可以转换为以下两种形式，返回结果均相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">p.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 创建一个promise并返回它</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// 使用值`42`完成</div><div class="line">		resolve( v * 2 );</div><div class="line">	&#125; );</div><div class="line">&#125; )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>引入异步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">p.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 创建一个promise并返回</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// 引入异步！</div><div class="line">		setTimeout( function()&#123;</div><div class="line">			// 使用值`42`完成</div><div class="line">			resolve( v * 2 );</div><div class="line">		&#125;, 100 );</div><div class="line">	&#125; );</div><div class="line">&#125; )</div><div class="line">.then( function(v)&#123;</div><div class="line">	// 在上一步中的100毫秒延迟之后运行</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>考虑发起Ajax请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 假定一个`ajax( &#123;url&#125;, &#123;callback&#125; )`工具</div><div class="line"></div><div class="line">// 带有Promise的ajax</div><div class="line">function request(url) &#123;</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// `ajax(..)`的回调应当是我们的promise的`resolve(..)`函数</div><div class="line">		ajax( url, resolve );</div><div class="line">	&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们首先定义一个<code>request(..)</code>工具，它构建一个promise表示<code>ajax(..)</code>调用的完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">request( &quot;http://some.url.1/&quot; )</div><div class="line">.then( function(response1)&#123;</div><div class="line">	return request( &quot;http://some.url.2/?v=&quot; + response1 );</div><div class="line">&#125; )</div><div class="line">.then( function(response2)&#123;</div><div class="line">	console.log( response2 );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>要是Promise链中的某一步出错了会怎样呢？一个错误/异常是基于每个Promise的，意味着在链条的任意一点捕获这些错误是可能的，而且这些捕获操作在那一点上将链条“重置”，使它回到正常的操作上来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 步骤 1:</div><div class="line">request( &quot;http://some.url.1/&quot; )</div><div class="line"></div><div class="line">// 步骤 2:</div><div class="line">.then( function(response1)&#123;</div><div class="line">	foo.bar(); // 没有定义，错误！</div><div class="line"></div><div class="line">	// 永远不会跑到这里</div><div class="line">	return request( &quot;http://some.url.2/?v=&quot; + response1 );</div><div class="line">&#125; )</div><div class="line"></div><div class="line">// 步骤 3:</div><div class="line">.then(</div><div class="line">	function fulfilled(response2)&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;,</div><div class="line">	// 拒绝处理器捕捉错误</div><div class="line">	function rejected(err)&#123;</div><div class="line">		console.log( err );	// 来自 `foo.bar()` 的 `TypeError` 错误</div><div class="line">		return 42;</div><div class="line">	&#125;</div><div class="line">)</div><div class="line"></div><div class="line">// 步骤 4:</div><div class="line">.then( function(msg)&#123;</div><div class="line">	console.log( msg );		// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h4 id="术语-Resolve（解析），Fulfill（完成），和Reject（拒绝）"><a href="#术语-Resolve（解析），Fulfill（完成），和Reject（拒绝）" class="headerlink" title="术语: Resolve（解析），Fulfill（完成），和Reject（拒绝）"></a>术语: Resolve（解析），Fulfill（完成），和Reject（拒绝）</h4><p>为什么用<code>resolve</code>而不用<code>fulfill</code>：</p>
<p><code>Promise.resolve(...)</code>将会直接返回收到的纯粹的Promise，或者将收到的thenable展开。如果展开thenable后是一个拒绝状态，那么从<code>Promise.resolve(...)</code>返回的Promise事实上是相同的拒绝状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var rejectedTh = &#123;</div><div class="line">	then: function(resolved,rejected) &#123;</div><div class="line">		rejected( &quot;Oops&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var rejectedPr = Promise.resolve( rejectedTh );</div><div class="line">rejectedPr.then(null,function(err) &#123;</div><div class="line">	console.log(err)</div><div class="line">&#125;);   // Oops</div></pre></td></tr></table></figure>
<p><code>Promise(..)</code>构造器的第一个回调参数既可以展开一个thenable（与<code>Promise.resolve(..)</code>相同），也可以展开一个Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var rejectedPr = new Promise( function(resolve,reject)&#123;</div><div class="line">	// 用一个被拒绝的promise来解析这个promise</div><div class="line">	resolve( Promise.reject( &quot;Oops&quot; ) );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">rejectedPr.then(</div><div class="line">	function fulfilled()&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		console.log( err );	// &quot;Oops&quot;</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>现在让我们将注意力转向提供给<code>then(..)</code>的回调。它们应当叫什么（在文献和代码中）？我的建议是<code>fulfilled(..)</code>和<code>rejected(..)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fulfilled(msg) &#123;</div><div class="line">	console.log( msg );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function rejected(err) &#123;</div><div class="line">	console.error( err );</div><div class="line">&#125;</div><div class="line"></div><div class="line">p.then(</div><div class="line">	fulfilled,</div><div class="line">	rejected</div><div class="line">);</div></pre></td></tr></table></figure>
<p>对于<code>then(..)</code>的第一个参数的情况，它没有歧义地总是完成状态，所以没有必要使用带有双重意义的“resolve”术语。另一方面，ES6语言规范中使用<code>onFulfilled(..)</code>和<code>onRejected(..)</code> 来标识这两个回调，所以它们是准确的术语。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p><code>catch</code>、<code>done</code></p>
<p><code>defer</code></p>
<h2 id="Promise模式"><a href="#Promise模式" class="headerlink" title="Promise模式"></a>Promise模式</h2><p><code>Promise.all([...])</code>期待一个单独的参数，一个<code>array</code>。从<code>Promise.all([...])</code>返回的promise将会收到完成的消息（即<code>msgs</code>），它是一个由所有被传入的promise的完成消息按照<strong>被传入的顺序</strong>构成的<code>array</code>（<strong>与完成的顺序无关</strong>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// `request(..)`是一个兼容Promise的Ajax工具</div><div class="line">// 就像我们在本章早前定义的</div><div class="line"></div><div class="line">var p1 = request( &quot;http://some.url.1/&quot; );</div><div class="line">var p2 = request( &quot;http://some.url.2/&quot; );</div><div class="line"></div><div class="line">Promise.all( [p1,p2] )</div><div class="line">.then( function(msgs)&#123;</div><div class="line">	// `p1`和`p2`都已完成，这里将它们的消息传入</div><div class="line">	return request(</div><div class="line">		&quot;http://some.url.3/?v=&quot; + msgs.join(&quot;,&quot;)</div><div class="line">	);</div><div class="line">&#125; )</div><div class="line">.then( function(msg)&#123;</div><div class="line">	console.log( msg );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>从<code>Promise.resolve(..)</code>返回的主Promise将会在所有组成它的promise完成之后才会被完成。如果其中任意一个promise被拒绝，<code>Promise.all([ .. ])</code>的主Promise将立即被拒绝，并放弃所有其他promise的结果。</p>
<h4 id="Promise-race-…"><a href="#Promise-race-…" class="headerlink" title="Promise.race([…])"></a>Promise.race([…])</h4><p>竞合（’race’），与竞合状态不同。</p>
<p>和<code>Promise.all([ .. ])</code>相似，<code>Promise.race([ .. ])</code>将会在任意一个Promise解析为完成时完成，而且它会在任意一个Promise解析为拒绝时拒绝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// `request(..)`是一个兼容Promise的Ajax工具</div><div class="line">// 就像我们在本章早前定义的</div><div class="line"></div><div class="line">var p1 = request( &quot;http://some.url.1/&quot; );</div><div class="line">var p2 = request( &quot;http://some.url.2/&quot; );</div><div class="line"></div><div class="line">Promise.race( [p1,p2] )</div><div class="line">.then( function(msg)&#123;</div><div class="line">	// `p1`或`p2`会赢得竞合</div><div class="line">	return request(</div><div class="line">		&quot;http://some.url.3/?v=&quot; + msg</div><div class="line">	);</div><div class="line">&#125; )</div><div class="line">.then( function(msg)&#123;</div><div class="line">	console.log( msg );</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<h5 id="超时竞合（Promise-race"><a href="#超时竞合（Promise-race" class="headerlink" title="超时竞合（Promise.race)"></a>超时竞合（Promise.race)</h5><p>我们早先看过这个例子，描述<code>Promise.race([ .. ])</code>如何能够用于表达“promise超时”模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// `foo()`是一个兼容Promise</div><div class="line"></div><div class="line">// `timeoutPromise(..)`在早前定义过，</div><div class="line">// 返回一个在指定延迟之后会被拒绝的Promise</div><div class="line"></div><div class="line">// 为`foo()`设置一个超时</div><div class="line">Promise.race( [</div><div class="line">	foo(),					// 尝试`foo()`</div><div class="line">	timeoutPromise( 3000 )	// 给它3秒钟</div><div class="line">] )</div><div class="line">.then(</div><div class="line">	function()&#123;</div><div class="line">		// `foo(..)`及时地完成了！</div><div class="line">	&#125;,</div><div class="line">	function(err)&#123;</div><div class="line">		// `foo()`要么是被拒绝了，要么就是没有及时完成</div><div class="line">		// 可以考察`err`来知道是哪一个原因</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h5 id="‘Finally’"><a href="#‘Finally’" class="headerlink" title="‘Finally’"></a>‘Finally’</h5><p>被丢弃、忽略的promise最终会变成垃圾回收的合法对象。</p>
<p> 所以用<code>finally(...)</code>回调注册机制，他总是在Promise解析时被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 42 );</div><div class="line"></div><div class="line">p.then( something )</div><div class="line">.finally( cleanup )</div><div class="line">.then( another )</div><div class="line">.finally( cleanup );</div></pre></td></tr></table></figure>
<h5 id="Promise-observe"><a href="#Promise-observe" class="headerlink" title="Promise.observe"></a>Promise.observe</h5><p>利用一个静态帮助工具类观察Promise的解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/ 填补的安全检查</div><div class="line">if (!Promise.observe) &#123;</div><div class="line">	Promise.observe = function(pr,cb) &#123;</div><div class="line">		// 从侧面观察`pr`的解析</div><div class="line">		pr.then(</div><div class="line">			function fulfilled(msg)&#123;</div><div class="line">				// 异步安排回调（作为Job）</div><div class="line">				Promise.resolve( msg ).then( cb );</div><div class="line">			&#125;,</div><div class="line">			function rejected(err)&#123;</div><div class="line">				// 异步安排回调（作为Job）</div><div class="line">				Promise.resolve( err ).then( cb );</div><div class="line">			&#125;</div><div class="line">		);</div><div class="line"></div><div class="line">		// 返回原本的promise</div><div class="line">		return pr;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是我们在前面的超时例子中如何使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Promise.race( [</div><div class="line">	Promise.observe(</div><div class="line">		foo(),					// 尝试`foo()`</div><div class="line">		function cleanup(msg)&#123;</div><div class="line">			// 在`foo()`之后进行清理，即便它没有及时完成</div><div class="line">		&#125;</div><div class="line">	),</div><div class="line">	timeoutPromise( 3000 )	// 给它3秒钟</div><div class="line">] )</div></pre></td></tr></table></figure>
<h5 id="all-与-race-的变种"><a href="#all-与-race-的变种" class="headerlink" title="all([ .. ]) 与 race([ .. ]) 的变种"></a>all([ .. ]) 与 race([ .. ]) 的变种</h5><p>原生的ES6Promise带有内建的<code>Promise.all([ .. ])</code>和<code>Promise.race([ .. ])</code>，这里还有几个关于这些语义的其他常用的变种模式：</p>
<ul>
<li><code>none([ .. ])</code>很像<code>all([ .. ])</code>，但是完成和拒绝被转置了。所有的Promise都需要被拒绝——拒绝变成了完成值，反之亦然。</li>
<li><code>any([ .. ])</code>很像<code>all([ .. ])</code>，但它忽略任何拒绝，所以只有一个需要完成即可，而不是它们所有的。</li>
<li><code>first([ .. ])</code>像是一个带有<code>any([ .. ])</code>的竞合，它忽略任何拒绝，而且一旦有一个Promise完成时，它就立即完成。</li>
<li><code>last([ .. ])</code>很像<code>first([ .. ])</code>，但是只有最后一个完成胜出。</li>
</ul>
<p>某些Promise抽象工具库提供这些方法，但你也可以用Promise机制的<code>race([ .. ])</code>和<code>all([ .. ])</code>，自己定义他们。</p>
<p>比如，这是我们如何定义<code>first([..])</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 填补的安全检查</div><div class="line">if (!Promise.first) &#123;</div><div class="line">	Promise.first = function(prs) &#123;</div><div class="line">		return new Promise( function(resolve,reject)&#123;</div><div class="line">			// 迭代所有的promise</div><div class="line">			prs.forEach( function(pr)&#123;</div><div class="line">				// 泛化它的值</div><div class="line">				Promise.resolve( pr )</div><div class="line">				// 无论哪一个首先成功完成，都由它来解析主promise</div><div class="line">				.then( resolve );</div><div class="line">			&#125; );</div><div class="line">		&#125; );</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这个<code>first(..)</code>的实现不会在它所有的promise都被拒绝时拒绝；它会简单地挂起，很像<code>Promise.race([])</code>。如果需要，你可以添加一些附加逻辑来追踪每个promise的拒绝，而且如果所有的都被拒绝，就在主promise上调用<code>reject()</code>。我们将此作为练习留给读者。</p>
<h4 id="并发迭代（Promise-map"><a href="#并发迭代（Promise-map" class="headerlink" title="并发迭代（Promise.map)"></a>并发迭代（Promise.map)</h4><p>用于迭代一个Promise列表：</p>
<p><code>Promise.map</code>它接受一个<code>array</code>值，外加一个对数组中每个值实施的函数。他的完成值是一个<code>array</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (!Promise.map) &#123;</div><div class="line">	Promise.map = function(vals,cb) &#123;</div><div class="line">		// 一个等待所有被映射的promise的新promise</div><div class="line">		return Promise.all(</div><div class="line">			// 注意：普通的数组`map(..)`，</div><div class="line">			// 将值的数组变为promise的数组</div><div class="line">			vals.map( function(val)&#123;</div><div class="line">				// 将`val`替换为一个在`val`</div><div class="line">				// 异步映射完成后才解析的新promise</div><div class="line">				return new Promise( function(resolve)&#123;</div><div class="line">					cb( val, resolve );</div><div class="line">				&#125; );</div><div class="line">			&#125; )</div><div class="line">		);</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var p1 = Promise.resolve( 21 );</div><div class="line">var p2 = Promise.resolve( 42 );</div><div class="line">var p3 = Promise.reject( &quot;Oops&quot; );</div><div class="line"></div><div class="line">// 将列表中的值翻倍，即便它们在Promise中</div><div class="line">Promise.map( [p1,p2,p3], function(pr,done)&#123;</div><div class="line">	// 确保列表中每一个值都是Promise</div><div class="line">	Promise.resolve( pr )</div><div class="line">	.then(</div><div class="line">		// 将值作为`v`抽取出来</div><div class="line">		function(v)&#123;</div><div class="line">			// 将完成的`v`映射到新的值</div><div class="line">			done( v * 2 );</div><div class="line">		&#125;,</div><div class="line">		// 或者，映射到promise的拒绝消息上</div><div class="line">		done</div><div class="line">	);</div><div class="line">&#125; )</div><div class="line">.then( function(vals)&#123;</div><div class="line">	console.log( vals );	// [42,84,&quot;Oops&quot;]</div><div class="line">&#125; );</div></pre></td></tr></table></figure>
<p>#第四章：Generator</p>
<h2 id="打破运行至完成"><a href="#打破运行至完成" class="headerlink" title="打破运行至完成"></a>打破运行至完成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var x = 1;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	x++;</div><div class="line">	bar();				// &lt;-- 这一行会发生什么？</div><div class="line">	console.log( &quot;x:&quot;, x );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	x++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();					// x: 3</div></pre></td></tr></table></figure>
<p>generator形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = 1;</div><div class="line"></div><div class="line">function *foo() &#123;    // 注意*的存在</div><div class="line">	x++;</div><div class="line">	yield; // 暂停！</div><div class="line">	console.log( &quot;x:&quot;, x );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	x++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function *foo(x,y) &#123;</div><div class="line">	return x * y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = foo( 6, 7 );</div><div class="line"></div><div class="line">var res = it.next();</div><div class="line"></div><div class="line">res.value;		// 42</div></pre></td></tr></table></figure>
<p><code>next(..)</code>调用的结果是一个带有<code>value</code>属性的对象，它持有从<code>*foo(..)</code>返回的任何值（如果有的话）。换句话说，<code>yield</code>导致在generator运行期间，一个值被从中发送出来，有点儿像一个中间的<code>return</code>。</p>
<h4 id="迭代通信"><a href="#迭代通信" class="headerlink" title="迭代通信"></a>迭代通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function *foo(x) &#123;</div><div class="line">	var y = x * (yield);</div><div class="line">	return y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = foo( 6 );</div><div class="line"></div><div class="line">// 开始`foo(..)`</div><div class="line">it.next();</div><div class="line"></div><div class="line">var res = it.next( 7 );</div><div class="line"></div><div class="line">res.value;		// 42</div></pre></td></tr></table></figure>
<p><code>it.next(7)</code>发送值<code>7</code>给暂停的<code>yield</code>表达式。</p>
<p><code>yield ...</code>和<code>next(...)</code>也可以一起成对地在generator运行期间构成一个双向消息传递系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function *foo(x) &#123;</div><div class="line">	var y = x * (yield &quot;Hello&quot;);	// &lt;-- 让出一个值！</div><div class="line">	return y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = foo( 6 );</div><div class="line"></div><div class="line">var res = it.next();	// 第一个`next()`，不传递任何东西</div><div class="line">res.value;				// &quot;Hello&quot;</div><div class="line"></div><div class="line">res = it.next( 7 );		// 传递`7`给等待中的`yield`</div><div class="line">res.value;				// 42</div></pre></td></tr></table></figure>
<p>第二个<code>next(7)</code>的应答值为<code>return y</code>提供，但<code>return</code>语句在generator中不是必须的，因为它总会有一个假定的<code>return</code>，即<code>return undefined</code>。</p>
<h3 id="多迭代器"><a href="#多迭代器" class="headerlink" title="多迭代器"></a>多迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function *foo() &#123;</div><div class="line">	var x = yield 2;</div><div class="line">	z++;</div><div class="line">	var y = yield (x * z);</div><div class="line">	console.log( x, y, z );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var z = 1;</div><div class="line"></div><div class="line">var it1 = foo();</div><div class="line">var it2 = foo();</div><div class="line"></div><div class="line">var val1 = it1.next().value;			// 2 &lt;-- 让出2</div><div class="line">var val2 = it2.next().value;			// 2 &lt;-- 让出2</div><div class="line"></div><div class="line">val1 = it1.next( val2 * 10 ).value;		// 40  &lt;-- x:20,  z:2</div><div class="line">val2 = it2.next( val1 * 5 ).value;		// 600 &lt;-- x:200, z:3</div><div class="line"></div><div class="line">it1.next( val2 / 2 );					// y:300</div><div class="line">										// 20 300 3</div><div class="line">it2.next( val1 / 4 );					// y:10</div><div class="line">										// 200 10 3</div></pre></td></tr></table></figure>
<h4 id="穿插"><a href="#穿插" class="headerlink" title="穿插"></a>穿插</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function step(gen) &#123;</div><div class="line">	var it = gen();</div><div class="line">	var last;</div><div class="line"></div><div class="line">	return function() &#123;</div><div class="line">		last = it.next( last ).value;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 1;</div><div class="line">var b = 2;</div><div class="line"></div><div class="line">function *foo() &#123;</div><div class="line">	a++;</div><div class="line">	yield;</div><div class="line">	b = b * a;</div><div class="line">	a = (yield b) + 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function *bar() &#123;</div><div class="line">	b--;</div><div class="line">	yield;</div><div class="line">	a = (yield 8) + b;</div><div class="line">	b = a * (yield 2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var s1 = step( foo );</div><div class="line">var s2 = step( bar );</div><div class="line"></div><div class="line">s2();		// b--;</div><div class="line">s2();		// 让出 8</div><div class="line">s1();		// a++;</div><div class="line">s2();		// a = 8 + b;</div><div class="line">			// 让出 2</div><div class="line">s1();		// b = b * a;</div><div class="line">			// 让出 b</div><div class="line">s1();</div><div class="line">s2();</div><div class="line">console.log(a,b);    // 12 18</div></pre></td></tr></table></figure>
<h2 id="生成值"><a href="#生成值" class="headerlink" title="生成值"></a>生成值</h2><h3 id="发生器与迭代器"><a href="#发生器与迭代器" class="headerlink" title="发生器与迭代器"></a>发生器与迭代器</h3><h4 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h4><p>它指包含有一个可以迭代它所有制的迭代器的对象。</p>
<p>在ES6中从一个<code>iterable</code>中取得一个迭代器的方法是：<em>iterable</em> 上必须有一个函数，它的名称是特殊的ES6符号值<code>Symbol.iterator</code>。当这个函数被调用时，它就会返回一个 <em>迭代器</em>。虽然不是必须的，但一般来说每次调用应当返回一个全新的 <em>迭代器</em>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = [1,3,5,7,9];</div><div class="line"></div><div class="line">var it = a[Symbol.iterator]();</div><div class="line"></div><div class="line">it.next().value;	// 1</div><div class="line">it.next().value;	// 3</div><div class="line">it.next().value;	// 5</div><div class="line">..</div></pre></td></tr></table></figure>
<h4 id="Generator迭代器"><a href="#Generator迭代器" class="headerlink" title="Generator迭代器"></a>Generator迭代器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function *something() &#123;</div><div class="line">	var nextVal;</div><div class="line"></div><div class="line">	while (true) &#123;</div><div class="line">		if (nextVal === undefined) &#123;</div><div class="line">			nextVal = 1;</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			nextVal = (3 * nextVal) + 6;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		yield nextVal;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (var v of something()) &#123;   //此时的something是一个generator</div><div class="line">	console.log( v );</div><div class="line"></div><div class="line">	// 不要让循环永无休止！</div><div class="line">	if (v &gt; 500) &#123;</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 1 9 33 105 321 969</div></pre></td></tr></table></figure>
<p>generator的 <em>迭代器</em> 上也有一个<code>Symbol.iterator</code>函数，这个函数基本上就是<code>return this</code>，就像我们刚才定义的<code>something</code><em>iterable</em>。换句话说generator的 <em>迭代器</em> 也是一个 <em>iterable</em>！</p>
<h5 id="停止Generator"><a href="#停止Generator" class="headerlink" title="停止Generator"></a>停止Generator</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function *something() &#123;</div><div class="line">	try &#123;</div><div class="line">		var nextVal;</div><div class="line"></div><div class="line">		while (true) &#123;</div><div class="line">			if (nextVal === undefined) &#123;</div><div class="line">				nextVal = 1;</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				nextVal = (3 * nextVal) + 6;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			yield nextVal;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	// 清理用的从句</div><div class="line">	finally &#123;</div><div class="line">		console.log( &quot;cleaning up!&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = something();</div><div class="line">for (var v of it) &#123;</div><div class="line">	console.log( v );</div><div class="line"></div><div class="line">	// 不要让循环永无休止！</div><div class="line">	if (v &gt; 500) &#123;</div><div class="line">		console.log(</div><div class="line">			// 使generator得迭代器完成</div><div class="line">			it.return( &quot;Hello World&quot; ).value</div><div class="line">		);</div><div class="line">		// 这里不需要`break`</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 1 9 33 105 321 969</div><div class="line">// cleaning up!</div><div class="line">// Hello World</div></pre></td></tr></table></figure>
<h2 id="异步地迭代Generator"><a href="#异步地迭代Generator" class="headerlink" title="异步地迭代Generator"></a>异步地迭代Generator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function foo(x,y) &#123;</div><div class="line">	ajax(</div><div class="line">		&quot;http://some.url.1/?x=&quot; + x + &quot;&amp;y=&quot; + y,</div><div class="line">		function(err,data)&#123;</div><div class="line">			if (err) &#123;</div><div class="line">				// 向`*main()`中扔进一个错误</div><div class="line">				it.throw( err );</div><div class="line">			&#125;</div><div class="line">			else &#123;</div><div class="line">				// 使用收到的`data`来继续`*main()`</div><div class="line">				it.next( data );</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function *main() &#123;</div><div class="line">	try &#123;</div><div class="line">		var text = yield foo( 11, 31 );</div><div class="line">		console.log( text );</div><div class="line">	&#125;</div><div class="line">	catch (err) &#123;</div><div class="line">		console.error( err );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = main();</div><div class="line"></div><div class="line">// 使一切开始运行！</div><div class="line">it.next();</div></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javaScript/" rel="tag"><i class="fa fa-tag"></i> javaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/08/You don't know js ( types & grammar ) 学习笔记/" rel="next" title="You don't know js ( types & grammar ) 学习笔记">
                <i class="fa fa-chevron-left"></i> You don't know js ( types & grammar ) 学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/20/express中的token/" rel="prev" title="express中的token">
                express中的token <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Shirley" />
          <p class="site-author-name" itemprop="name">Shirley</p>
           
              <p class="site-description motion-element" itemprop="description">Only when you plant the flowers can you really smell their fragrance.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：异步：现在与稍后"><span class="nav-number">1.</span> <span class="nav-text">第一章：异步：现在与稍后</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#块儿（Chunks）中的程序"><span class="nav-number">1.1.</span> <span class="nav-text">块儿（Chunks）中的程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步控制台"><span class="nav-number">1.1.1.</span> <span class="nav-text">异步控制台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件轮询（Event-Loop）"><span class="nav-number">1.2.</span> <span class="nav-text">事件轮询（Event Loop）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行线程"><span class="nav-number">1.3.</span> <span class="nav-text">并行线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行至完成"><span class="nav-number">1.3.1.</span> <span class="nav-text">运行至完成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发"><span class="nav-number">1.4.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#非互动"><span class="nav-number">1.4.1.</span> <span class="nav-text">非互动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互动"><span class="nav-number">1.4.2.</span> <span class="nav-text">互动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协作"><span class="nav-number">1.4.3.</span> <span class="nav-text">协作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jobs"><span class="nav-number">1.5.</span> <span class="nav-text">Jobs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句排序"><span class="nav-number">1.6.</span> <span class="nav-text">语句排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：回调"><span class="nav-number">2.</span> <span class="nav-text">第二章：回调</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套-链接的回调"><span class="nav-number">2.1.</span> <span class="nav-text">嵌套/链接的回调</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章：Promises"><span class="nav-number">3.</span> <span class="nav-text">第三章：Promises</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Promise"><span class="nav-number">3.1.</span> <span class="nav-text">什么是Promise?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#完成事件"><span class="nav-number">3.1.1.</span> <span class="nav-text">完成事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise”事件“"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Promise”事件“</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise的信任"><span class="nav-number">3.2.</span> <span class="nav-text">Promise的信任</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调的太早"><span class="nav-number">3.2.1.</span> <span class="nav-text">调的太早</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调的太晚"><span class="nav-number">3.2.2.</span> <span class="nav-text">调的太晚</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise排程的怪现象"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">Promise排程的怪现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可信的Promise"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">可信的Promise?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thenable鸭子类型（Duck-Typing）"><span class="nav-number">3.3.</span> <span class="nav-text">Thenable鸭子类型（Duck Typing）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式流程"><span class="nav-number">3.4.</span> <span class="nav-text">链式流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#术语-Resolve（解析），Fulfill（完成），和Reject（拒绝）"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">术语: Resolve（解析），Fulfill（完成），和Reject（拒绝）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">4.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise模式"><span class="nav-number">4.1.</span> <span class="nav-text">Promise模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-race-…"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">Promise.race([…])</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#超时竞合（Promise-race"><span class="nav-number">4.1.0.1.1.</span> <span class="nav-text">超时竞合（Promise.race)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#‘Finally’"><span class="nav-number">4.1.0.1.2.</span> <span class="nav-text">‘Finally’</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-observe"><span class="nav-number">4.1.0.1.3.</span> <span class="nav-text">Promise.observe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#all-与-race-的变种"><span class="nav-number">4.1.0.1.4.</span> <span class="nav-text">all([ .. ]) 与 race([ .. ]) 的变种</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发迭代（Promise-map"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">并发迭代（Promise.map)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打破运行至完成"><span class="nav-number">4.2.</span> <span class="nav-text">打破运行至完成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入和输出"><span class="nav-number">4.2.1.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代通信"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">迭代通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多迭代器"><span class="nav-number">4.2.2.</span> <span class="nav-text">多迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#穿插"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">穿插</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成值"><span class="nav-number">4.3.</span> <span class="nav-text">生成值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发生器与迭代器"><span class="nav-number">4.3.1.</span> <span class="nav-text">发生器与迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterables"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">Iterables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator迭代器"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">Generator迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#停止Generator"><span class="nav-number">4.3.1.2.1.</span> <span class="nav-text">停止Generator</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步地迭代Generator"><span class="nav-number">4.4.</span> <span class="nav-text">异步地迭代Generator</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shirley</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共44.2k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  


  

</body>
</html>
