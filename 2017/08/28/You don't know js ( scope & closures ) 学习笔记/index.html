<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javaScript," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="第一章：什么是作用域？编译器理论 js是一种编译型语言，它 不是 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。 传统编译型语言处理，一块代码执行之前的处理分为三个步骤，成为“编译”：  词法分析">
<meta name="keywords" content="javaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="You don&#39;t know js (scope&amp;closures) 学习笔记">
<meta property="og:url" content="http:/four27.com/2017/08/28/You don't know js ( scope & closures ) 学习笔记/index.html">
<meta property="og:site_name" content="Shirley&#39;s Blog">
<meta property="og:description" content="第一章：什么是作用域？编译器理论 js是一种编译型语言，它 不是 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。 传统编译型语言处理，一块代码执行之前的处理分为三个步骤，成为“编译”：  词法分析">
<meta property="og:updated_time" content="2017-11-18T04:38:30.741Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="You don&#39;t know js (scope&amp;closures) 学习笔记">
<meta name="twitter:description" content="第一章：什么是作用域？编译器理论 js是一种编译型语言，它 不是 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。 传统编译型语言处理，一块代码执行之前的处理分为三个步骤，成为“编译”：  词法分析">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http:/four27.com/2017/08/28/You don't know js ( scope & closures ) 学习笔记/"/>





  <title>You don't know js (scope&closures) 学习笔记 | Shirley's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shirley's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:/four27.com/2017/08/28/You don't know js ( scope & closures ) 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">You don't know js (scope&closures) 学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-28T16:04:25+08:00">
                2017-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javaScript学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">javaScript学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一章：什么是作用域？"><a href="#第一章：什么是作用域？" class="headerlink" title="第一章：什么是作用域？"></a>第一章：什么是作用域？</h1><h2 id="编译器理论"><a href="#编译器理论" class="headerlink" title="编译器理论"></a>编译器理论</h2><p> <strong>js是一种编译型语言</strong>，它 <em>不是</em> 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。</p>
<p>传统编译型语言处理，一块代码执行之前的处理分为三个步骤，成为“编译”：</p>
<ul>
<li>词法分析</li>
</ul>
<a id="more"></a>
<ul>
<li>语法分析</li>
<li>代码生成</li>
</ul>
<p>和大多数其他语言的编译器一样，JavaScript 引擎要比这区区三步复杂太多了。</p>
<p>其一，javaScript 引擎没有（像其他语言的编译器那样）大把的时间去优化，因为 javaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中。对 javaScript 来说，在许多情况下，编译发生在代码被执行前的仅仅几微秒之内（或更少！）。为了确保最快的性能，JS 引擎将使用所有的招数（比如 JIT，它可以懒编译甚至是热编译，等等），而这远超出了我们关于“作用域”的讨论。</p>
<!-- more -->
<h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>以<code>var a = 2;</code>为例，用一个对话情形了解释作用域。</p>
<h3 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h3><p>1、<strong>引擎</strong>：负责从始至终的编译和执行javaScript程序。</p>
<p>2、<strong>编译器</strong>：引擎的朋友之一，负责解析和代码生成。</p>
<p>3、<strong>作用域</strong>：引擎的有一个朋友，收集并维护含有所有被声明标识符（变量）的一张表，并对当前执行中的代码如何访问这些代码制定严格的规则。</p>
<h3 id="反复"><a href="#反复" class="headerlink" title="反复"></a>反复</h3><p>引擎会看到两个语句：一个是编译器需要处理的语句，一个是引擎在执行期间处理的语句。</p>
<p>编译器对于<code>var a = 2</code>的处理过程：</p>
<p>1、遇到 <code>var a</code>，<em>编译器</em> 让 <em>作用域</em> 去查看对于这个特定的作用域集合，变量 <code>a</code> 是否已经存在了。如果是，<em>编译器</em> 就忽略这个声明并继续前进。否则，<em>编译器</em> 就让 <em>作用域</em> 去为这个作用域集合声明一个称为 <code>a</code> 的新变量。</p>
<p>2、然后 <em>编译器</em> 为 <em>引擎</em> 生成稍后要执行的代码，来处理赋值 <code>a = 2</code>。<em>引擎</em> 运行的代码首先让 <em>作用域</em> 去查看在当前的作用域集合中是否有一个称为 <code>a</code> 的变量可以访问。如果有，<em>引擎</em> 就使用这个变量。如果没有，<em>引擎</em> 就查看 <em>其他地方</em>。如果 <em>引擎</em> 最终找到一个变量，它就将值 <code>2</code> 赋予它。如果没有，<em>引擎</em> 将会举起它的手并喊出一个错误！</p>
<p>总结来说：对于一个变量赋值，发生了两个不同的动作：第一，<em>编译器</em> 声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，<em>引擎</em> 在 <em>作用域</em> 中查询这个变量并给它赋值，如果找到的话。</p>
<h3 id="编译器术语"><a href="#编译器术语" class="headerlink" title="编译器术语"></a>编译器术语</h3><p><strong>RHS（right hand side）查询 &amp; LHS（left hand side）查询</strong></p>
<p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。更简单的理解RHS：意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值“。例：</p>
<blockquote>
<p>console.log( a );</p>
</blockquote>
<p>这个指向 <code>a</code> 的引用是一个 RHS 引用，因为这里没有东西被赋值给 <code>a</code>。而是我们在查询 <code>a</code> 并取得它的值，这样这个值可以被传递进 <code>console.log(..)</code>。</p>
<p>作为对比：</p>
<blockquote>
<p>a = 2;</p>
</blockquote>
<p>这里指向 <code>a</code> 的引用是一个 LHS 引用，因为我们实际上不关心当前的值是什么，我们只是想找到这个变量，将它作为 <code>= 2</code> 赋值操作的目标。</p>
<h3 id="引擎-amp-作用域对话"><a href="#引擎-amp-作用域对话" class="headerlink" title="引擎 &amp; 作用域对话"></a>引擎 &amp; 作用域对话</h3><p>这是解释RHS和LHS更具体的一个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	console.log( a ); // 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>让我们将上面的（处理这个代码段的）交互想象为一场对话。这场对话将会有点儿像这样进行：</p>
<blockquote>
<p><strong>引擎</strong>：嘿 <em>作用域</em>，我有一个 <code>foo</code> 的 RHS 引用。听说过它吗？</p>
<p><strong>作用域</strong>；啊，是的，听说过。<em>编译器</em> 刚在一秒钟之前声明了它。它是一个函数。给你。</p>
<p><strong>引擎</strong>：太棒了，谢谢！好的，我要执行 <code>foo</code> 了。</p>
<p><strong>引擎</strong>：嘿，<em>作用域</em>，我得到了一个 <code>a</code> 的 LHS 引用，听说过它吗？</p>
<p><strong>作用域</strong>：啊，是的，听说过。<em>编译器</em> 刚才将它声明为 <code>foo</code> 的一个正式参数了。给你。</p>
<p><strong>引擎</strong>：一如既往的给力，<em>作用域</em>。再次感谢你。现在，该把 <code>2</code> 赋值给 <code>a</code> 了。</p>
<p><strong>引擎</strong>：嘿，<em>作用域</em>，很抱歉又一次打扰你。我需要 RHS 查询 <code>console</code>。听说过它吗？</p>
<p><strong>作用域</strong>：没关系，<em>引擎</em>，这是我一天到晚的工作。是的，我得到 <code>console</code> 了。它是一个内建对象。给你。</p>
<p><strong>引擎</strong>：完美。查找 <code>log(..)</code>。好的，很好，它是一个函数。</p>
<p><strong>引擎</strong>：嘿，<em>作用域</em>。你能帮我查一下 <code>a</code> 的 RHS 引用吗？我想我记得它，但只是想再次确认一下。</p>
<p><strong>作用域</strong>：你是对的，<em>引擎</em>。同一个家伙，没变。给你。</p>
<p><strong>引擎</strong>：酷。传递 <code>a</code> 的值，也就是 <code>2</code>，给 <code>log(..)</code>。</p>
<p>…</p>
</blockquote>
<h3 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h3><p>检查你到目前为止的理解。确保你扮演 <em>引擎</em>，并与 <em>作用域</em> “对话”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	var b = a;</div><div class="line">	return a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var c = foo( 2 );</div></pre></td></tr></table></figure>
<ol>
<li>找到所有的 LHS 查询（有3处！）。</li>
<li>找到所有的 RHS 查询（有4处！）。</li>
</ol>
<p><strong>答案</strong></p>
<ol>
<li><p>找出所有的 LHS 查询（有3处！）。</p>
<p><strong>c = .., a = 2（隐含的参数赋值）和 b = ..</strong></p>
</li>
<li><p>找出所有的 RHS 查询（有4处！）。</p>
<p><strong>foo(2.., = a;, a + .. 和 .. + b</strong></p>
<p>​</p>
</li>
</ol>
<h2 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h2><p><strong>引擎</strong> 在查找一个变量，如果在直接作用域上找不到的话，<strong>引擎</strong> 就会咨询下一个外层作用域，以此类推， 直到找到这个变量或者到达最外层作用域，即全局作用域。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	console.log( a + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var b = 2;</div><div class="line"></div><div class="line">foo( 2 ); // 4</div></pre></td></tr></table></figure>
<p>该例中在查找<code>b</code>值时，要使用RHS查询。这个过程描述为一个简单的对话：</p>
<blockquote>
<p><strong>引擎</strong>：“嘿，<code>foo</code> 的 <em>作用域</em>，听说过 <code>b</code> 吗？我得到一个它的 RHS 引用。”</p>
<p><strong>作用域</strong>：“没有，从没听说过。问问别人吧。”</p>
<p><strong>引擎</strong>：“嘿，<code>foo</code> 外面的 <em>作用域</em>，哦，你是全局 <em>作用域</em>，好吧，酷。听说过 <code>b</code> 吗？我得到一个它的 RHS 引用。”</p>
<p><strong>作用域</strong>：“是的，当然有。给你。”</p>
</blockquote>
<h2 id="错误（？）"><a href="#错误（？）" class="headerlink" title="错误（？）"></a>错误（？）</h2><p>为什么我们区别 LHS 和 RHS 那么重要？</p>
<p>因为在变量还没有被声明（在所有被查询的 <em>作用域</em> 中都没找到）的情况下，这两种类型的查询的行为不同。</p>
<p>考虑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	console.log( a + b );</div><div class="line">	b = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo( 2 );</div></pre></td></tr></table></figure>
<p>当 <code>b</code> 的 RHS 查询第一次发生时，它是找不到的。它被说成是一个“未声明”的变量，因为它在作用域中找不到。</p>
<p>如果 RHS 查询在嵌套的 <em>作用域</em> 的任何地方都找不到一个值，这会导致 <em>引擎</em> 抛出一个 <code>ReferenceError</code>。必须要注意的是这个错误的类型是 <code>ReferenceError</code>。</p>
<p><strong>相比之下，如果 <em>引擎</em> 在进行一个 LHS 查询，但到达了顶层（全局 <em>作用域</em>）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 <em>作用域</em> 将会在 全局作用域中创建一个同名的新变量，并把它交还给 引擎。</strong>（能不能举一个具体的栗子？）</p>
<p><em>“不，之前没有这样的东西，但是我可以帮忙给你创建一个。”</em></p>
<p>在 ES5 中被加入的“Strict模式”[^note-strictmode]，有许多与一般/宽松/懒惰模式不同的行为。其中之一就是不允许自动/隐含的全局变量创建。在这种情况下，将不会有全局 <em>作用域</em> 的变量交回给 LHS 查询，并且类似于 RHS 的情况, <em>引擎</em> 将抛出一个 <code>ReferenceError</code>。</p>
<p>现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 <code>null</code> 或者 <code>undefined</code> 值的属性，那么 <em>引擎</em> 就会抛出一个不同种类的错误，称为 <code>TypeError</code>。</p>
<p><code>ReferenceError</code> 是关于 <em>作用域</em> 解析失败的，而 <code>TypeError</code> 暗示着 <em>作用域</em> 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。</p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。</p>
<p><strong>手动划重点：</strong>未被满足的 RHS 引用会导致 <code>ReferenceError</code> 被抛出。未被满足的 LHS 引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict模式”[^note-strictmode]），或者一个 <code>ReferenceError</code>（如果是“Strict模式”[^note-strictmode]）。</p>
<h1 id="第二章：-词法作用域"><a href="#第二章：-词法作用域" class="headerlink" title="第二章： 词法作用域"></a>第二章： 词法作用域</h1><p>作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 <strong>词法作用域</strong>，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 <strong>动态作用域</strong>。</p>
<h2 id="词法分析时"><a href="#词法分析时" class="headerlink" title="词法分析时"></a>词法分析时</h2><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line"></div><div class="line">	var b = a * 2;</div><div class="line"></div><div class="line">	function bar(c) &#123;</div><div class="line">		console.log( a, b, c );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	bar(b * 3);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo( 2 ); // 2 4 12</div></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>当引擎执行<code>console.log(...)</code>语句时，它需要查找三个变量<code>a</code>，<code>b</code>，<code>c</code>。</p>
<p>查找三个变量的方式都为一层一层从内到外的查找，<strong>一旦找到第一个匹配，作用域查询就停止了</strong>。</p>
<p>当相同的标识符在作用域的多个层中指定时，内部的标识符会“遮蔽”外层的标识符。</p>
<p>全局变量自动的是全局对象（在浏览器中是<code>window</code>等等）的属性，所以对全局变量的引用可以不直接通过词法名称，可以通过将它作为全局对象的一个属性来间接的引用。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.a</div></pre></td></tr></table></figure>
<h2 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h2><p>欺骗词法作用域即修改词法作用域。<strong>欺骗词法作用域会导致性能低下。</strong></p>
<p>js中欺骗词法作用域有两种机制。</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>javaScript中的<code>eval(...)</code>函数接收一个字符串作为参数值，并把这个字符串的内容转换为代码。从而改变函数的作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(str, a) &#123;</div><div class="line">	eval( str ); // 作弊！</div><div class="line">	console.log( a, b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var b = 2;</div><div class="line"></div><div class="line">foo( &quot;var b = 3;&quot;, 1 ); // 1 3</div></pre></td></tr></table></figure>
<p>上面的代码中，变量<code>str</code>的值<code>&quot;var b = 2&quot;</code>的值会转换成一行代码。这个时候整个代码就可以解读为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(str, a) &#123;</div><div class="line">	str = &quot;var b = 3&quot;;</div><div class="line">	var b = 3;</div><div class="line">	console.log( a, b );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var b = 2;</div><div class="line"></div><div class="line">foo( &quot;var b = 3;&quot;, 1 ); // 1 3</div></pre></td></tr></table></figure>
<p>因此控制台中输出的<code>b</code>值就为<code>3</code>而不是<code>2</code>。</p>
<p><strong>注意</strong>：当<code>eval</code>操作的作用域内为strict模式时，<code>eval(...)</code>内部做出的声明不会修改作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(str) &#123;</div><div class="line">   &quot;use strict&quot;;</div><div class="line">   eval( str );</div><div class="line">   console.log( a ); // ReferenceError: a is not defined</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo( &quot;var a = 2&quot; );</div></pre></td></tr></table></figure>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p><code>with</code>现在已经被废弃了。</p>
<p>以下为<code>with</code>的一种使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	a: 1,</div><div class="line">	b: 2,</div><div class="line">	c: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//  重复“obj”显得更“繁冗”</div><div class="line">obj.a = 2;</div><div class="line">obj.b = 3;</div><div class="line">obj.c = 4;</div><div class="line"></div><div class="line">// “更简单”的缩写</div><div class="line">with (obj) &#123;</div><div class="line">	a = 3;</div><div class="line">	b = 4;</div><div class="line">	c = 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而以下代码才是<code>with</code>带来的麻烦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function foo(obj) &#123;</div><div class="line">	with (obj) &#123;</div><div class="line">		a = 2;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var o1 = &#123;</div><div class="line">	a: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var o2 = &#123;</div><div class="line">	b: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo( o1 );</div><div class="line">console.log( o1.a ); // 2</div><div class="line"></div><div class="line">foo( o2 );</div><div class="line">console.log( o2.a ); // undefined</div><div class="line">console.log( a ); // 2 -- 哦，全局作用域被泄漏了！</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>o1</code>对象有<code>a</code>属性，而<code>o2</code>对象没有<code>a</code>属性。这就是产生问题的原因啦，<code>foo(...)</code>分别将<code>o1</code>和<code>o2</code>作为参数。因为<code>o1</code>对象有<code>a</code>属性，所以<code>console.log( o1.a )</code>的输出值为<code>2</code>。但是<code>o2</code>对象没有<code>a</code>属性，当运行<code>with(...)</code>时，<code>a = 2</code>会按照LSH标识符查询规则，因为这不是在strict模式下，所有会在全局内声明一个变量<code>a</code>，并赋值为<code>2</code>。</p>
<p>如果 <code>eval(..)</code> 函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而 <code>with</code> 语句实际上是从你传递给它的对象中凭空制造了一个 <strong>全新的词法作用域</strong>。</p>
<p><strong>注意：</strong> 除了使用它们是个坏主意以外，<code>eval(..)</code> 和 <code>with</code> 都受Strict模式的影响（制约）。<code>with</code> 干脆就不允许使用，而虽然 <code>eval(..)</code> 还保有其核心功能，但各种间接形式的或不安全的 <code>eval(..)</code> 是不允许的。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如果 <code>eval(..)</code> 或 <code>with</code> 出现，那么它做的所有的优化几乎都会变得没有意义，所以引擎就会简单地根本不做任何优化。</p>
<p>你的代码几乎肯定会趋于运行的更慢，只因为你在代码的任何地方引入了一个了 <code>eval(..)</code> 或 <code>with</code>。无论引擎将在努力限制这些悲观臆测的副作用上表现得多么聪明，<strong>都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。</strong></p>
<h1 id="第三章：函数与块作用域"><a href="#第三章：函数与块作用域" class="headerlink" title="第三章：函数与块作用域"></a>第三章：函数与块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(a) &#123;</div><div class="line">	var b = 2;</div><div class="line"></div><div class="line">	// 一些代码</div><div class="line"></div><div class="line">	function bar() &#123;</div><div class="line">		// ...</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 更多代码</div><div class="line"></div><div class="line">	var c = 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在全局作用域中可访问<code>foo(...)</code>，在<code>foo(...)</code>作用域中可访问<code>b</code>，<code>bar()</code>，<code>c</code>。</p>
<h2 id="隐藏于普通作用域"><a href="#隐藏于普通作用域" class="headerlink" title="隐藏于普通作用域"></a>隐藏于普通作用域</h2><p>隐藏作用域就相当于把代码封装到一个函数中，然后在另一个函数中调用这个函数，这样函数中很多细节就隐藏在了被调用的函数中。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function doSomething(a) &#123;</div><div class="line">	b = a + doSomethingElse( a * 2 );</div><div class="line"></div><div class="line">	console.log( b * 3 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function doSomethingElse(a) &#123;</div><div class="line">	return a - 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var b;</div><div class="line"></div><div class="line">doSomething( 2 ); // 15</div><div class="line">console.log( a ); // 5    自己加的测试代码</div></pre></td></tr></table></figure>
<p>但在上述的代码中，<code>doSomethingElse</code>很可能被其他函数使用，改变<code>doSomethingElse</code>内容，违背了<code>doSomethingElse</code>为<code>doSomething</code>私有细节这一点，所以可以将代码变更为下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function doSomething(a) &#123;</div><div class="line">	function doSomethingElse(a) &#123;</div><div class="line">		return a - 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var b;</div><div class="line"></div><div class="line">	b = a + doSomethingElse( a * 2 );</div><div class="line"></div><div class="line">	console.log( b * 3 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">doSomething( 2 ); // 15</div></pre></td></tr></table></figure>
<p>这是<code>doSomethingElse</code>完全为<code>doSomething</code>内部私有，外部无法更改。这种将私有细节保持为私有的做法是被提倡的。</p>
<h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>在同一个函数中会发生使用相同的标识符，从而产生了值被覆盖的这种情况。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	function bar(a) &#123;</div><div class="line">		i = 3; // 在外围的for循环的作用域中改变`i`</div><div class="line">		console.log( a + i );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for (var i=0; i&lt;10; i++) &#123;</div><div class="line">		bar( i * 2 ); // 噢，无限循环！</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>其中<code>i = 3</code>会该表<code>for</code>循环中<code>i</code>的值，从而使<code>for</code>循环进入无线循环的状态。但如果将<code>i = 3</code>改为<code>var i = 3</code>就不会产生这种情况。这是因为<code>bar(...)</code>函数中，未声明变量<code>i</code>，所以在非严格模式下，根据LSH标识符查询原则，在<code>foo(...)</code>中<code>i</code>会被声明为一个全局变量。</p>
<h4 id="全局“名称空间”（不是很理解）"><a href="#全局“名称空间”（不是很理解）" class="headerlink" title="全局“名称空间”（不是很理解）"></a>全局“名称空间”（不是很理解）</h4><p>变量冲突很有可能发生在全局作用域中。当多个库被加载到程序中时，如果没有适当的隐藏私有变量和函数，就很容易发生冲突。</p>
<p>所以，这样的库通常在全局作用域中使用一个独特的名称来声明一个对象，然后这些库的名称和内容组成对象中的键值对。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var MyReallyCoolLibrary = &#123;</div><div class="line">	awesome: &quot;stuff&quot;,</div><div class="line">	doSomething: function() &#123;</div><div class="line">		// ...</div><div class="line">	&#125;,</div><div class="line">	doAnotherThing: function() &#123;</div><div class="line">		// ...</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>（这样就能回避冲突？？？？为啥？？？？）</p>
<h4 id="模块管理（喵？）"><a href="#模块管理（喵？）" class="headerlink" title="模块管理（喵？）"></a>模块管理（喵？）</h4><p>另一种回避冲突的选择是通过任意一种依赖管理器，使用更加现代的“模块”方式。使用这些工具，没有库可以向全局作用域添加任何标识符，取而代之的是使用依赖管理器的各种机制，要求库的标识符被明确地导入到另一个指定的作用域中。</p>
<p>应该可以看到，这些工具并不拥有可以豁免于词法作用域规则的“魔法”功能。它们简单地使用这里讲解的作用域规则，来强制标识符不会被注入任何共享的作用域，而是保持在私有的，不易冲突的作用域中，这防止了任何意外的作用域冲突。</p>
<p>因此，如果你选择这样做的话，你可以防御性地编码，并在实际上不使用依赖管理器的情况下，取得与使用它们相同的结果。关于模块模式的更多信息参见第五章。</p>
<p>（那我们就第五章再说吧）</p>
<h2 id="函数作为作用域"><a href="#函数作为作用域" class="headerlink" title="函数作为作用域"></a>函数作为作用域</h2><p>区别下面两段代码：</p>
<p>第一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">function foo() &#123; // &lt;-- 插入这个</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line"></div><div class="line">&#125; // &lt;-- 和这个</div><div class="line">foo(); // &lt;-- 还有这个</div><div class="line"></div><div class="line">console.log( a ); // 2</div></pre></td></tr></table></figure>
<p>第二段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function foo()&#123; // &lt;-- 插入这个</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line"></div><div class="line">&#125;)(); // &lt;-- 和这个</div><div class="line"></div><div class="line">console.log( a ); // 2</div></pre></td></tr></table></figure>
<p>两段代码都调用了<code>foo</code>函数，在第一段代码中<code>foo</code>是一个函数声明，而在第二段代码中<code>foo</code>是一个函数表达式。</p>
<p>区分函数声明和函数表达式：判断语句中（不仅仅是一行，而是一个独立的语句）“function”一词的位置。如果“function”是这个语句中的第一个东西，那么它就是一个函数声明。否则，它就是一个函数表达式。</p>
<p>在第一段代码中：名称<code>foo</code>被绑定在外围作用域中，我们可以用<code>foo()</code>直接调用。</p>
<p>在第二段代码中：名称<code>foo</code>没有被帮绑定在外围作用域中，而是被绑定在它的函数内部。</p>
<h3 id="匿名与命名"><a href="#匿名与命名" class="headerlink" title="匿名与命名"></a>匿名与命名</h3><p>匿名函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( function()&#123;</div><div class="line">	console.log(&quot;I waited 1 second!&quot;);</div><div class="line">&#125;, 1000 );</div></pre></td></tr></table></figure>
<p>优点：匿名函数表达式能更快的键入。</p>
<p>缺点：1、在栈轨迹上匿名函数没有名称，这可能会使调试更加困难。</p>
<p>​        2、没有名称的情况下，如果函数想要再次引用自己，就需要使用<strong>被遗弃</strong>了的<code>arguments.callee</code>。</p>
<p>​            3、匿名函数省略的名称有利于标识函数的具体作用。</p>
<p>命名函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( function timeoutHandler()&#123; // &lt;-- 看，我有一个名字！</div><div class="line">	console.log( &quot;I waited 1 second!&quot; );</div><div class="line">&#125;, 1000 );</div></pre></td></tr></table></figure>
<p><strong>内联函数表达式</strong> 很强大且很有用 —— 匿名和命名的问题并不会贬损这一点。给你的函数表达式提供一个名称就可以十分有效地解决这些缺陷，而且没有实际的坏处。最佳的方法是总是命名你的函数表达式：</p>
<h4 id="栈轨迹（自己补充部分）"><a href="#栈轨迹（自己补充部分）" class="headerlink" title="栈轨迹（自己补充部分）"></a>栈轨迹（自己补充部分）</h4><h5 id="（函数）调用栈"><a href="#（函数）调用栈" class="headerlink" title="（函数）调用栈"></a>（函数）调用栈</h5><p>函数调用栈工作方式：后进先出（LIFO:last in, first out）。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function c() &#123;</div><div class="line">    console.log(&apos;c&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function b() &#123;</div><div class="line">    console.log(&apos;b&apos;);</div><div class="line">    c();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function a() &#123;</div><div class="line">    console.log(&apos;a&apos;);</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div></pre></td></tr></table></figure>
<p>在上述栗子中，<code>a</code>首先被运行，这是<code>a</code>就进入了堆栈的顶部。当<code>a</code>中运行<code>b</code>时，<code>b</code>被添加到堆栈的顶部。当<code>b</code>中运行<code>c</code>时，<code>c</code>被添加到堆栈的顶部。当<code>c</code>运行时，堆栈中就包含了<code>a</code>，<code>b</code>，<code>c</code>。当<code>c</code>运行完后，就会从堆栈的顶部被移除，然后<code>b</code>，<code>a</code>运行完后也同样。</p>
<p>为了更好的观察，可以使用<code>console.trace()</code>在控制台输出当前的堆栈数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function c() &#123;</div><div class="line">    console.log(&apos;c&apos;);</div><div class="line">    console.trace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function b() &#123;</div><div class="line">    console.log(&apos;b&apos;);</div><div class="line">    c();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function a() &#123;</div><div class="line">    console.log(&apos;a&apos;);</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div></pre></td></tr></table></figure>
<h3 id="立即调用函数表达式（IIFE-（？）"><a href="#立即调用函数表达式（IIFE-（？）" class="headerlink" title="立即调用函数表达式（IIFE)（？）"></a>立即调用函数表达式（IIFE)（？）</h3><p>传统IIFE两种书写方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function foo()&#123;</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">console.log( a ); // 2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function foo()&#123;</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line"></div><div class="line">&#125;());</div><div class="line"></div><div class="line">console.log( a ); // 2</div></pre></td></tr></table></figure>
<p>两种书写方式在功能上完全相同，<strong>纯粹根据个人喜好选择</strong>。</p>
<p>一种十分常见的变种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function IIFE( global )&#123;</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line">	console.log( global.a ); // 2</div><div class="line"></div><div class="line">&#125;)( window );</div><div class="line"></div><div class="line">console.log( a ); // 2</div></pre></td></tr></table></figure>
<p>传入<code>window</code>对象引用，将参数命名为<code>global</code>。这样就能通过<code>global</code>参数访问全局变量<code>a</code>。</p>
<p>另一种变种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = 2;</div><div class="line"></div><div class="line">(function IIFE( def )&#123;</div><div class="line">	def( window );</div><div class="line">&#125;)(function def( global )&#123;</div><div class="line"></div><div class="line">	var a = 3;</div><div class="line">	console.log( a ); // 3</div><div class="line">	console.log( global.a ); // 2</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种变种将事情的顺序倒了过来，要被执行的函数在调用和传递给它的参数 <em>之后</em> 给出。这种模式被用于 UMD（Universal Module Definition —— 统一模块定义）项目。一些人发现它更干净和易懂一些，虽然有点儿繁冗。</p>
<h2 id="块儿作为作用域"><a href="#块儿作为作用域" class="headerlink" title="块儿作为作用域"></a>块儿作为作用域</h2><p>两段常见的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i=0; i&lt;10; i++) &#123;</div><div class="line">	console.log( i );  // 0 1 2 3 4 5 6 7 8 9 </div><div class="line">&#125;</div><div class="line">console.log(i)    // 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var foo = true;</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">	var bar = foo * 2;</div><div class="line">	bar = something( bar );</div><div class="line">	console.log( bar );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述两段代码中的的<code>i</code>和<code>bar</code>虽然分别声明在<code>for</code>和<code>if</code>块儿内，但是还是属于全局变量。</p>
<h3 id="with-1"><a href="#with-1" class="headerlink" title="with"></a>with</h3><p>它是一个块儿作用域的例子，它从对象中创建的作用域仅存在于这个 <code>with</code> 语句的生命周期中，而不在外围作用域中。</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><p>在 <code>try/catch</code> 的 <code>catch</code> 子句中声明的变量，是属于 <code>catch</code> 块儿的块儿作用域的。</p>
<p>栗如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">	undefined(); //用非法的操作强制产生一个异常！</div><div class="line">&#125;</div><div class="line">catch (err) &#123;</div><div class="line">	console.log( err ); // 好用！</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( err ); // ReferenceError: `err` not found</div></pre></td></tr></table></figure>
<p>但是当<code>catch</code>里面也含有<code>catch</code>时，参数如果都为<code>err</code>许多 linter 依然会报警。所以为了避免这一问题出现，我们会用<code>err1</code>和<code>err2</code>来区分他们，或者关掉<code>linter</code>。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code> 关键字将变量声明附着在它所在的任何块儿（通常是一个 <code>{ .. }</code>）的作用域中。换句话说，<code>let</code> 为它的变量声明隐含地劫持了任意块儿的作用域。</p>
<p>我们可以在一个语句是合法文法的任何地方，通过简单地引入一个 <code>{ .. }</code> 来为 <code>let</code> 创建一个任意的可以绑定的块儿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = true;</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">	&#123; // &lt;-- 明确的块儿</div><div class="line">		let bar = foo * 2;</div><div class="line">		bar = something( bar );</div><div class="line">		console.log( bar );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( bar ); // ReferenceError</div></pre></td></tr></table></figure>
<p>使用 <code>let</code> 做出的声明将 <em>不会</em> 在它们所出现的整个块儿的作用域中提升。即不能先使用后声明变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   console.log( bar ); // ReferenceError!</div><div class="line">   let bar = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function process(data) &#123;</div><div class="line">	// 做些有趣的事</div><div class="line">&#125;</div><div class="line"></div><div class="line">var someReallyBigData = &#123; .. &#125;;</div><div class="line"></div><div class="line">process( someReallyBigData );</div><div class="line"></div><div class="line">var btn = document.getElementById( &quot;my_button&quot; );</div><div class="line"></div><div class="line">btn.addEventListener( &quot;click&quot;, function click(evt)&#123;</div><div class="line">	console.log(&quot;button clicked&quot;);</div><div class="line">&#125;, /*capturingPhase=*/false );</div></pre></td></tr></table></figure>
<p>在上面的代码中，当运行完<code>process( someReallyBigData )</code>后，后面的代码就不需要<code>someReallyBigData</code>变量了。所以当运行<code>click</code>事件时，js引擎就不需要继续保持<code>someReallyBigData</code>变量了。为了解决这一问题可以用<code>let</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function process(data) &#123;</div><div class="line">	// 做些有趣的事</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行过后，任何定义在这个块中的东西都可以消失了</div><div class="line">&#123;</div><div class="line">	let someReallyBigData = &#123; .. &#125;;</div><div class="line"></div><div class="line">	process( someReallyBigData );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var btn = document.getElementById( &quot;my_button&quot; );</div><div class="line"></div><div class="line">btn.addEventListener( &quot;click&quot;, function click(evt)&#123;</div><div class="line">	console.log(&quot;button clicked&quot;);</div><div class="line">&#125;, /*capturingPhase=*/false );</div></pre></td></tr></table></figure>
<h4 id="let循环（-）"><a href="#let循环（-）" class="headerlink" title="let循环（*）"></a>let循环（*）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=0; i&lt;10; i++) &#123;</div><div class="line">	console.log( i );</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( i ); // ReferenceError</div></pre></td></tr></table></figure>
<p><code>let</code>循环的特点是：每一次循环都会重新绑定<code>i</code>，然后再对它进行赋值。上述代码等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	let j;</div><div class="line">	for (j=0; j&lt;10; j++) &#123;</div><div class="line">		let i = j; // 每次迭代都重新绑定</div><div class="line">		console.log( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>声明的变量也为块作用域，只不过他声明后的值是不可改变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var foo = true;</div><div class="line"></div><div class="line">if (foo) &#123;</div><div class="line">	var a = 2;</div><div class="line">	const b = 3; // 存在于包含它的`if`作用域中</div><div class="line"></div><div class="line">	a = 3; // 没问题！</div><div class="line">	b = 4; // 错误！</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( a ); // 3</div><div class="line">console.log( b ); // ReferenceError!</div></pre></td></tr></table></figure>
<h1 id="第四章：提升"><a href="#第四章：提升" class="headerlink" title="第四章：提升"></a>第四章：提升</h1><p>先考虑以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = 2;</div><div class="line"></div><div class="line">var a;</div><div class="line"></div><div class="line">console.log( a );   // 2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log( a ); // undefined</div><div class="line"></div><div class="line">var a = 2;</div></pre></td></tr></table></figure>
<h2 id="编译器再次来袭（？）"><a href="#编译器再次来袭（？）" class="headerlink" title="编译器再次来袭（？）"></a>编译器再次来袭（？）</h2><p>引擎将会在解释执行代码之前先对它进行编译。编译的部分过程就是找到所有声明，并将它们<strong>关联在合适的作用域上</strong>。</p>
<p>所以在代码执行之前，所有函数和变量的声明都会被首先处理。</p>
<p>对于<code>var a = 2;</code>这段代码，js实际认为它是两个语句：<code>var a;</code>和<code>a = 2;</code>。第一个语句：声明，是在编译阶段处理的，是编译期的任务。第二个语句：赋值，为了执行阶段留在原处，是执行期的任务。</p>
<p>所以上面的第一段代码被解释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = 2;</div><div class="line">console.log( a );  // 2</div></pre></td></tr></table></figure>
<p>第二段代码被解释为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log( a );</div><div class="line">a = 2;</div></pre></td></tr></table></figure>
<p><strong>变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”这个名字。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	console.log( a ); // undefined</div><div class="line"></div><div class="line">	var a = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述的代码可以解释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo () &#123;</div><div class="line">  var a;</div><div class="line">  </div><div class="line">  console.log( a );</div><div class="line">  </div><div class="line">  a = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div></pre></td></tr></table></figure>
<p><strong>函数声明会被提升，但函数表达式不会。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo(); // TypeError</div><div class="line">bar(); // ReferenceError</div><div class="line"></div><div class="line">var foo = function bar() &#123;</div><div class="line">	// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这段代码可以解释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo;</div><div class="line"></div><div class="line">foo();    //TypeError   虽然声明了，但是foo没有赋值，运行一个undefined的值是一种错误的操作。</div><div class="line">bar();    //ReferenceError  没有声明</div><div class="line"></div><div class="line">foo = function () &#123;</div><div class="line">  var bar = ...self...;  (喵喵喵？？？)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数会比变量先提升。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">foo(); // 1</div><div class="line"></div><div class="line">var foo;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	console.log( 1 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo = function() &#123;</div><div class="line">	console.log( 2 );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这段代码被引擎解释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( 1 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); // 1</div><div class="line"></div><div class="line">foo = function() &#123;</div><div class="line">	console.log( 2 );</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>var foo;</code>被省略了，因为在函数声明之后这一步是重复操作了。即便它出现在 <code>function foo()...</code> 声明之前，因为函数声明是在普通变量之前被提升的。</p>
<p>对于多个声明，后续声明会覆盖前一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">foo(); // 3</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	console.log( 1 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">var foo = function() &#123;</div><div class="line">	console.log( 2 );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	console.log( 3 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在普通的块儿内部出现的函数声明一般会被提升至外围的作用域，而不是像这段代码暗示的那样有条件地被定义：</p>
<figure class="highlight plain"><figcaption><span>basic</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">foo(); // &quot;b&quot;</div><div class="line"></div><div class="line">var a = true;</div><div class="line">if (a) &#123;</div><div class="line">   function foo() &#123; console.log( &quot;a&quot; ); &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">   function foo() &#123; console.log( &quot;b&quot; ); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种行为是不可靠的，而且是未来版本的 JavaScript 将要改变的对象，所以避免在块儿中声明函数可能是最好的做法。</p>
<h1 id="第五章：作用域闭包"><a href="#第五章：作用域闭包" class="headerlink" title="第五章：作用域闭包"></a>第五章：作用域闭包</h1><h2 id="事实真相"><a href="#事实真相" class="headerlink" title="事实真相"></a>事实真相</h2><p>闭包的定义：</p>
<blockquote>
<p>闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。</p>
</blockquote>
<p>一个闭包的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	var a = 2;</div><div class="line"></div><div class="line">	function bar() &#123;</div><div class="line">		console.log( a );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var baz = foo();</div><div class="line"></div><div class="line">baz(); // 2 -- 哇噢，看到闭包了，伙计。</div></pre></td></tr></table></figure>
<p>在<code>foo</code>中，声明了一个<code>bar</code>函数，它可以访问外围作用域的<code>a</code>变量。通过<code>return bar;</code>可以成功的将<code>bar</code>这个函数传给其他任意变量。将<code>foo()</code>赋值给<code>baz</code>变量，这时直接调用<code>baz()</code>就能成功的在控制台输出变量<code>a</code>。</p>
<p>在上述的代码中，<code>foo()</code>按理执行完之后就会被引擎启用垃圾回收器 来回收<code>foo()</code>内部的内容。但是闭包不会让这一事件发生，内部的作用域依然可以使用。</p>
<p><strong>bar() 依然拥有对那个作用域的引用，而这个引用称为闭包。</strong></p>
<p>而且，函数也可以作为参数传递，在其他地方使用这个传递进去的参数，也是闭包的一种实现形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	var a = 2;</div><div class="line"></div><div class="line">	function baz() &#123;</div><div class="line">		console.log( a ); // 2</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	bar( baz );</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar(fn) &#123;</div><div class="line">	fn(); // 看妈妈，我看到闭包了！</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以将函数传给外部作用域的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var fn;</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">	var a = 2;</div><div class="line"></div><div class="line">	function baz() &#123;</div><div class="line">		console.log( a );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fn = baz; // 将`baz`赋值给一个全局变量</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	fn(); // 看妈妈，我看到闭包了！</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div><div class="line"></div><div class="line">bar(); // 2</div></pre></td></tr></table></figure>
<h2 id="现在我能看到了"><a href="#现在我能看到了" class="headerlink" title="现在我能看到了"></a>现在我能看到了</h2><p>举一个特殊栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function wait(message) &#123;</div><div class="line"></div><div class="line">	setTimeout( function timer()&#123;</div><div class="line">		console.log( message );</div><div class="line">	&#125;, 1000 );</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">wait( &quot;Hello, closure!&quot; );</div></pre></td></tr></table></figure>
<p><code>setTimeout</code>内的<code>timer</code>拥有覆盖<code>wait</code>作用域的闭包，保持着对<code>message</code>变量的引用。</p>
<p>正是因为闭包的存在，才能在函数执行了1000ms后，在<code>wait()</code>内部作用域已经消失的情况下，输出变量<code>message</code>的值。</p>
<h2 id="循环-闭包（-）"><a href="#循环-闭包（-）" class="headerlink" title="循环+闭包（*）"></a>循环+闭包（*）</h2><p>用来展示闭包最常见最权威的例子是老实巴交的 for 循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">	setTimeout( function timer()&#123;</div><div class="line">		console.log( i );</div><div class="line">	&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行上述代码，会发现每隔一秒会输出一个6。</p>
<h3 id="setTimeout下的循环和闭包（自己补充部分）"><a href="#setTimeout下的循环和闭包（自己补充部分）" class="headerlink" title="setTimeout下的循环和闭包（自己补充部分）"></a>setTimeout下的循环和闭包（自己补充部分）</h3><p>对于上述代码的理解：结合<strong>异步</strong>、<strong>闭包</strong>和<strong>作用域</strong>的知识。</p>
<h4 id="对setTimeout的理解"><a href="#对setTimeout的理解" class="headerlink" title="对setTimeout的理解"></a>对setTimeout的理解</h4><p>首先要理清对setTimeout的理解：</p>
<blockquote>
<p>setTimeout的延迟不是绝对精确的；<br>setTimeout的意思是传递一个函数，延迟一段时候把该函数添加到队列当中，并不是立即执行；<br>所以说如果当前正在运行的代码没有运行完，即使延迟的时间已经过完，该函数会等待到函数队列中前面所有的函数运行完毕之后才会运行；</p>
</blockquote>
<p><strong>也就是说所有传递给setTimeout的回调方法都会在整个环境下的所有代码运行完毕之后执行。</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;</div><div class="line">        console.log(&quot;here&quot;);</div><div class="line">    &#125;, 2000);</div><div class="line">    var i = 0;</div><div class="line">    //具体数值根据你的计算机CPU来决定，达到延迟效果就好</div><div class="line">    while (i &lt; 300000000) &#123;</div><div class="line">        i ++;</div><div class="line">    &#125;</div><div class="line">    console.log(&quot;test&quot;);</div></pre></td></tr></table></figure>
<p>上面的代码运行时，会先输出test，2秒后再输出here。</p>
<h4 id="为什么是一秒"><a href="#为什么是一秒" class="headerlink" title="为什么是一秒"></a>为什么是一秒</h4><p>因为根据上述的理解，<code>setTimeout</code>会在<code>for</code>循环结束后运行，所以队列中会依次加入延迟1秒、2秒、3秒…的<code>setTimeout</code>函数，所以在运行的时候延迟1秒的会先运行，然后对于延迟2秒的在延迟1秒的<code>setTimeout</code>运行的同时也跟着延迟了1秒，所以当延迟1秒的<code>setTimeout</code>运行结束后，只需要延迟1秒就可以开始运行函数。 延迟3秒、4秒…的同理。</p>
<h4 id="为什么每次都显示6"><a href="#为什么每次都显示6" class="headerlink" title="为什么每次都显示6"></a>为什么每次都显示6</h4><p>可以将循环转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var i;</div><div class="line">for(i = 1; i &lt;= 5; i++) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>首先说明对于闭包的理解：对函数类型的值进行传递时，保留对它<strong>被声明的位置所处的作用域</strong>的引用。</p>
<p>timer函数是在setTimeout中声明的，当运行<code>console.log( i )</code>时，这个<code>i</code>在<code>timer</code>里面没有声明，所以向外层作用域找，这时候可以找到全局作用域上的<code>i</code>。当<code>timer</code>执行时，循环已经结束了，所以<code>i</code>的值为6。</p>
<h4 id="改进后输出1-2-3-4-5"><a href="#改进后输出1-2-3-4-5" class="headerlink" title="改进后输出1,2,3,4,5"></a>改进后输出1,2,3,4,5</h4><p>第一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">	(function()&#123;</div><div class="line">		var j = i;</div><div class="line">		setTimeout( function timer()&#123;</div><div class="line">			console.log( j );</div><div class="line">		&#125;, j*1000 );</div><div class="line">	&#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数在每次迭代时，持有一个<code>i</code>值的拷贝。</p>
<p>第二种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">  (function (j) &#123;</div><div class="line">  	setTimeout(function timer () &#123;</div><div class="line">      console.log( j );</div><div class="line">  	&#125;, j * 1000);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式知识上面形式的一种改写，他们都会利用IIFE来解决这一问题，都是<strong>用立即执行函数表达式创造了新的函数作用域将timer函数包裹了起来，并用j捕获了每次循环时的i</strong>。只不过第二种方式将<code>j</code>作为形参，<code>i</code>作为实参。</p>
<p>第三种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (let i=1; i&lt;=5; i++) &#123;</div><div class="line">	setTimeout( function timer()&#123;</div><div class="line">		console.log( i );</div><div class="line">	&#125;, i*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>let</code>声明的变量每次都会创建一个块作用域，将上面的代码经过babel转码为ES5我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var _loop = function _loop(i) &#123;</div><div class="line">	setTimeout(function timer() &#123;</div><div class="line">		console.log(i);</div><div class="line">	&#125;, i * 1000);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">	_loop(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它为每一次循环都创建了一个块作用域。</p>
<p>第四种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (var i=1; i&lt;=5; i++) &#123;</div><div class="line">	let j = i;</div><div class="line">	setTimeout( function timer()&#123;</div><div class="line">		console.log( j );</div><div class="line">	&#125;, j*1000 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式原理和第三种方式相同。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>闭包的另一种运用是在模块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function CoolModule() &#123;</div><div class="line">	var something = &quot;cool&quot;;</div><div class="line">	var another = [1, 2, 3];</div><div class="line"></div><div class="line">	function doSomething() &#123;</div><div class="line">		console.log( something );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function doAnother() &#123;</div><div class="line">		console.log( another.join( &quot; ! &quot; ) );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return &#123;</div><div class="line">		doSomething: doSomething,</div><div class="line">		doAnother: doAnother</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var foo = CoolModule();</div><div class="line"></div><div class="line">foo.doSomething(); // cool</div><div class="line">foo.doAnother(); // 1 ! 2 ! 3</div></pre></td></tr></table></figure>
<p>这段代码就是闭包在模块中的一个运用。实现模块的一个最常用方法经常被称为“揭示模块”。</p>
<p>对于上述代码需要注意的是：</p>
<p>第一：<code>coolModule()</code>只是一个函数，它只有被调用之后才能称为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。</p>
<p>第二：<code>CoolModule()</code> 函数返回一个对象，通过对象字面量语法 <code>{ key: value, ... }</code> 标记。可以很恰当地认为这个返回值对象实质上是一个 <strong>我们模块的公有API</strong>。</p>
<p>行使模块模式有两个“必要条件”：</p>
<ol>
<li>必须有一个外部的外围函数，而且它必须至少被调用一次（每次创建一个新的模块实例）。</li>
<li>外围的函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问和/或修改这个私有状态。</li>
</ol>
<p>一个仅带有一个函数属性的对象不是 <em>真正</em> 的模块。从可观察的角度来说，一个从函数调用中返回的对象，仅带有数据属性而没有闭包的函数，也不是 <em>真正</em> 的模块。</p>
<p>只需要一个实例的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var foo = (function CoolModule() &#123;</div><div class="line">	var something = &quot;cool&quot;;</div><div class="line">	var another = [1, 2, 3];</div><div class="line"></div><div class="line">	function doSomething() &#123;</div><div class="line">		console.log( something );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function doAnother() &#123;</div><div class="line">		console.log( another.join( &quot; ! &quot; ) );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return &#123;</div><div class="line">		doSomething: doSomething,</div><div class="line">		doAnother: doAnother</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">foo.doSomething(); // cool</div><div class="line">foo.doAnother(); // 1 ! 2 ! 3</div></pre></td></tr></table></figure>
<p>使用IIFE实现。</p>
<p>同时，模块是函数，所以它们可以接受参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function CoolModule(id) &#123;</div><div class="line">	function identify() &#123;</div><div class="line">		console.log( id );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return &#123;</div><div class="line">		identify: identify</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var foo1 = CoolModule( &quot;foo 1&quot; );</div><div class="line">var foo2 = CoolModule( &quot;foo 2&quot; );</div><div class="line"></div><div class="line">foo1.identify(); // &quot;foo 1&quot;</div><div class="line">foo2.identify(); // &quot;foo 2&quot;</div></pre></td></tr></table></figure>
<p>同时，我们还可以通过模块内部函数修改公有API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var foo = (function CoolModule(id) &#123;</div><div class="line">	function change() &#123;</div><div class="line">		// 修改公有 API</div><div class="line">		publicAPI.identify = identify2;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function identify1() &#123;</div><div class="line">		console.log( id );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function identify2() &#123;</div><div class="line">		console.log( id.toUpperCase() );</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var publicAPI = &#123;</div><div class="line">		change: change,</div><div class="line">		identify: identify1</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	return publicAPI;</div><div class="line">&#125;)( &quot;foo module&quot; );</div><div class="line"></div><div class="line">foo.identify(); // foo module</div><div class="line">foo.change();</div><div class="line">foo.identify(); // FOO MODULE</div></pre></td></tr></table></figure>
<h3 id="现代的模块"><a href="#现代的模块" class="headerlink" title="现代的模块"></a>现代的模块</h3><h3 id="未来的模块"><a href="#未来的模块" class="headerlink" title="未来的模块"></a>未来的模块</h3><h1 id="附录A：动态作用域"><a href="#附录A：动态作用域" class="headerlink" title="附录A：动态作用域"></a>附录A：动态作用域</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	console.log( a ); // 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">function bar() &#123;</div><div class="line">	var a = 3;</div><div class="line">	foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = 2;</div><div class="line"></div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>在 <code>foo()</code> 的词法作用域中指向 <code>a</code> 的 RHS 引用将被解析为全局变量 <code>a</code>，它将导致输出结果为值 <code>2</code>。</p>
<p>相比之下，动态作用域本身不关心函数和作用域是在哪里和如何被声明的，而是关心 <strong>它们是从何处被调用的</strong>。换句话说，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。</p>
<h1 id="附录B：填补块作用域"><a href="#附录B：填补块作用域" class="headerlink" title="附录B：填补块作用域"></a>附录B：填补块作用域</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javaScript/" rel="tag"><i class="fa fa-tag"></i> javaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/18/You don‘t know js（up & going）学习笔记/" rel="next" title="You don't know js(up & going)学习笔记">
                <i class="fa fa-chevron-left"></i> You don't know js(up & going)学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/12/You don't know js ( this & object prototypes ) 学习笔记/" rel="prev" title="You don't know js ( this & object prototypes ) 学习笔记">
                You don't know js ( this & object prototypes ) 学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Shirley" />
          <p class="site-author-name" itemprop="name">Shirley</p>
           
              <p class="site-description motion-element" itemprop="description">Only when you plant the flowers can you really smell their fragrance.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章：什么是作用域？"><span class="nav-number">1.</span> <span class="nav-text">第一章：什么是作用域？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器理论"><span class="nav-number">1.1.</span> <span class="nav-text">编译器理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解作用域"><span class="nav-number">1.2.</span> <span class="nav-text">理解作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#演员"><span class="nav-number">1.2.1.</span> <span class="nav-text">演员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反复"><span class="nav-number">1.2.2.</span> <span class="nav-text">反复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器术语"><span class="nav-number">1.2.3.</span> <span class="nav-text">编译器术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引擎-amp-作用域对话"><span class="nav-number">1.2.4.</span> <span class="nav-text">引擎 & 作用域对话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小测验"><span class="nav-number">1.2.5.</span> <span class="nav-text">小测验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套的作用域"><span class="nav-number">1.3.</span> <span class="nav-text">嵌套的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误（？）"><span class="nav-number">1.4.</span> <span class="nav-text">错误（？）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复习"><span class="nav-number">1.5.</span> <span class="nav-text">复习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：-词法作用域"><span class="nav-number">2.</span> <span class="nav-text">第二章： 词法作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#词法分析时"><span class="nav-number">2.1.</span> <span class="nav-text">词法分析时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询"><span class="nav-number">2.1.1.</span> <span class="nav-text">查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#欺骗词法作用域"><span class="nav-number">2.2.</span> <span class="nav-text">欺骗词法作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eval"><span class="nav-number">2.2.1.</span> <span class="nav-text">eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#with"><span class="nav-number">2.2.2.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">2.2.3.</span> <span class="nav-text">性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章：函数与块作用域"><span class="nav-number">3.</span> <span class="nav-text">第三章：函数与块作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数中的作用域"><span class="nav-number">3.1.</span> <span class="nav-text">函数中的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐藏于普通作用域"><span class="nav-number">3.2.</span> <span class="nav-text">隐藏于普通作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#避免冲突"><span class="nav-number">3.2.1.</span> <span class="nav-text">避免冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局“名称空间”（不是很理解）"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">全局“名称空间”（不是很理解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块管理（喵？）"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">模块管理（喵？）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数作为作用域"><span class="nav-number">3.3.</span> <span class="nav-text">函数作为作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名与命名"><span class="nav-number">3.3.1.</span> <span class="nav-text">匿名与命名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈轨迹（自己补充部分）"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">栈轨迹（自己补充部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（函数）调用栈"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">（函数）调用栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即调用函数表达式（IIFE-（？）"><span class="nav-number">3.3.2.</span> <span class="nav-text">立即调用函数表达式（IIFE)（？）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块儿作为作用域"><span class="nav-number">3.4.</span> <span class="nav-text">块儿作为作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#with-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-catch"><span class="nav-number">3.4.2.</span> <span class="nav-text">try/catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let"><span class="nav-number">3.4.3.</span> <span class="nav-text">let</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let循环（-）"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">let循环（*）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">3.4.4.</span> <span class="nav-text">const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章：提升"><span class="nav-number">4.</span> <span class="nav-text">第四章：提升</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器再次来袭（？）"><span class="nav-number">4.1.</span> <span class="nav-text">编译器再次来袭（？）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数优先"><span class="nav-number">4.2.</span> <span class="nav-text">函数优先</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章：作用域闭包"><span class="nav-number">5.</span> <span class="nav-text">第五章：作用域闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事实真相"><span class="nav-number">5.1.</span> <span class="nav-text">事实真相</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现在我能看到了"><span class="nav-number">5.2.</span> <span class="nav-text">现在我能看到了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环-闭包（-）"><span class="nav-number">5.3.</span> <span class="nav-text">循环+闭包（*）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout下的循环和闭包（自己补充部分）"><span class="nav-number">5.3.1.</span> <span class="nav-text">setTimeout下的循环和闭包（自己补充部分）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对setTimeout的理解"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">对setTimeout的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么是一秒"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">为什么是一秒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么每次都显示6"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">为什么每次都显示6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进后输出1-2-3-4-5"><span class="nav-number">5.3.1.4.</span> <span class="nav-text">改进后输出1,2,3,4,5</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-number">5.4.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#现代的模块"><span class="nav-number">5.4.1.</span> <span class="nav-text">现代的模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未来的模块"><span class="nav-number">5.4.2.</span> <span class="nav-text">未来的模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录A：动态作用域"><span class="nav-number">6.</span> <span class="nav-text">附录A：动态作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录B：填补块作用域"><span class="nav-number">7.</span> <span class="nav-text">附录B：填补块作用域</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shirley</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共46.3k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  


  

</body>
</html>
